C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CAN
OBJECT MODULE PLACED IN .\DP8051\DP8051_Keil_951\Debug\CAN.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.2\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\CAN.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB DF(DEBUG) WL(2)
                    - PR(.\DP8051\DP8051_Keil_951\Debug/CAN.lst) CD OT(2,SIZE) OJ(.\DP8051\DP8051_Keil_951\Debug\CAN.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: CAN.c
   3          * Version 3.0
   4          *
   5          * Description:
   6          *  The CAN Component provides functionality of Control Area Network.
   7          *  The two types of mailbox configuration available are "Full" and "Basic".
   8          *
   9          * Note:
  10          *  The CAN configuration is put as constant to ROM and can be changed
  11          *  only directly by the registers written by the user.
  12          *
  13          ********************************************************************************
  14          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  15          * You may use this file only in accordance with the license, terms, conditions,
  16          * disclaimers, and limitations in the end user license agreement accompanying
  17          * the software package with which this file was provided.
  18          *******************************************************************************/
  19          
  20          #include "CAN.h"
  21          
  22          uint8 CAN_initVar = 0u;
  23          
  24          
  25          /*******************************************************************************
  26          * FUNCTION NAME:   CAN_RxTxBuffersConfig
  27          ********************************************************************************
  28          *
  29          * Summary:
  30          *  Inits/Restores default CAN Rx and Tx Buffers control registers configuration
  31          *  provided by the customizer.
  32          *
  33          * Parameters:
  34          *  None.
  35          *
  36          * Return:
  37          *  The indication whether the configuration has been accepted or rejected.
  38          *   Define                             Description
  39          *    CYRET_SUCCESS                      The function passed successfully
  40          *    CAN_FAIL              The function failed
  41          *
  42          * Side Effects:
  43          *  All the Rx and Tx Buffers control registers will be reset to their initial
  44          *  values.
  45          *
  46          *******************************************************************************/
  47          uint8 CAN_RxTxBuffersConfig(void) 
  48          {
  49   1          /* Initial values of CAN RX and TX registers */
  50   1          static const CAN_RX_CFG CYCODE CAN_RXConfigStruct[] =
  51   1          {
  52   1              { 0u, 0x8000A8u, 0xFFFFFFFFu, 0x0u },
  53   1              { 1u, 0x0u, 0x0u, 0x0u },
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 2   

  54   1              { 2u, 0x0u, 0x0u, 0x0u },
  55   1              { 3u, 0x0u, 0x0u, 0x0u },
  56   1              { 4u, 0x0u, 0x0u, 0x0u },
  57   1              { 5u, 0x0u, 0x0u, 0x0u },
  58   1              { 6u, 0x0u, 0x0u, 0x0u },
  59   1              { 7u, 0x0u, 0x0u, 0x0u },
  60   1              { 8u, 0x0u, 0x0u, 0x0u },
  61   1              { 9u, 0x0u, 0x0u, 0x0u },
  62   1              { 10u, 0x0u, 0x0u, 0x0u },
  63   1              { 11u, 0x0u, 0x0u, 0x0u },
  64   1              { 12u, 0x0u, 0x0u, 0x0u },
  65   1              { 13u, 0x0u, 0x0u, 0x0u },
  66   1              { 14u, 0x0u, 0x0u, 0x0u },
  67   1              { 15u, 0x0u, 0x0u, 0x0u }
  68   1          };
  69   1      
  70   1          static const CAN_TX_CFG CYCODE CAN_TXConfigStruct[] =
  71   1          {
  72   1              { 0u, 0x80000u, 0x200000u },
  73   1              { 1u, 0x180000u, 0x10u },
  74   1              { 2u, 0x0u, 0x0u },
  75   1              { 3u, 0x0u, 0x0u },
  76   1              { 4u, 0x0u, 0x0u },
  77   1              { 5u, 0x0u, 0x0u },
  78   1              { 6u, 0x0u, 0x0u },
  79   1              { 7u, 0x0u, 0x0u }
  80   1          };
  81   1      
  82   1          uint8 result = CYRET_SUCCESS;
  83   1          uint8 i;
  84   1      
  85   1          /* Initialize TX mailboxes */
  86   1          for (i = 0u; i < CAN_NUMBER_OF_TX_MAILBOXES; i++)
  87   1          {
  88   2              if (CAN_TxBufConfig((const CAN_TX_CFG *)
  89   2                  (&CAN_TXConfigStruct[i])) != CYRET_SUCCESS)
  90   2              {
  91   3                  result = CAN_FAIL;
  92   3                  break;
  93   3              }
  94   2          }
  95   1      
  96   1          if (result == CYRET_SUCCESS)
  97   1          {
  98   2              /* Initialize RX mailboxes */
  99   2              for (i = 0u; i < CAN_NUMBER_OF_RX_MAILBOXES; i++)
 100   2              {
 101   3                  if (CAN_RxBufConfig((const CAN_RX_CFG *)
 102   3                      (&CAN_RXConfigStruct[i])) != CYRET_SUCCESS)
 103   3                  {
 104   4                      result = CAN_FAIL;
 105   4                      break;
 106   4                  }
 107   3              }
 108   2          }
 109   1      
 110   1          return (result);
 111   1      }
 112          
 113          
 114          /*******************************************************************************
 115          * FUNCTION NAME:   CAN_Init
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 3   

 116          ********************************************************************************
 117          *
 118          * Summary:
 119          *  Inits/Restores default CAN configuration provided by the customizer.
 120          *
 121          * Parameters:
 122          *  None.
 123          *
 124          * Return:
 125          *  The indication whether the configuration has been accepted or rejected.
 126          *   Define                             Description
 127          *    CYRET_SUCCESS                      The function passed successfully
 128          *    CAN_FAIL              The function failed
 129          *
 130          * Side Effects:
 131          *  All the registers will be reset to their initial values. This will
 132          *  re-initialize the component with the following exceptions - it will not clear
 133          *  data from the mailboxes.
 134          *  Enable power to the CAN Core.
 135          *
 136          *******************************************************************************/
 137          uint8 CAN_Init(void) 
 138          {
 139   1          uint32 timeout = CAN_MODE_STATE_STOP_TIMEOUT;
 140   1          uint8 result = CAN_FAIL;
 141   1          uint8 localResult = CAN_FAIL;
 142   1      
 143   1          #if (CY_PSOC3 || CY_PSOC5)
 144   1              uint8 enableInterrupts;
 145   1      
 146   1              enableInterrupts = CyEnterCriticalSection();
 147   1              /* Enable CAN block in Active mode */
 148   1              CAN_PM_ACT_CFG_REG |= CAN_ACT_PWR_EN;
 149   1              /* Enable CAN block in Alternate Active (Standby) mode */
 150   1              CAN_PM_STBY_CFG_REG |= CAN_STBY_PWR_EN;
 151   1              CyExitCriticalSection(enableInterrupts);
 152   1      
 153   1              /* Sets CAN controller to stop mode */
 154   1              CAN_CMD_REG.byte[0u] &= (uint8) (~CAN_MODE_MASK);
 155   1      
 156   1              /* Timeout for CAN state machine to switch mode to Stop */
 157   1              while ((timeout != 0u) && ((CAN_CMD_REG.byte[0u] & CAN_MODE_MASK) != 0u))
 158   1              {
 159   2                  timeout--;
 160   2              }
 161   1          #else  /* CY_PSOC4 */
                      /* Enable CAN IP Block */
                      CAN_CNTL_REG = CAN_IP_ENABLE;
              
                      /* Sets CAN controller to stop mode */
                      CAN_CMD_REG &= (uint32) (~((uint32) CAN_MODE_MASK));
              
                      /* Timeout for CAN state machine to switch mode to Stop */
                      while ((timeout != 0u) && ((CAN_CMD_REG & CAN_MODE_MASK) != 0u))
                      {
                          timeout--;
                      }
                  #endif /* CY_PSOC3 || CY_PSOC5 */
 174   1              if (timeout != 0u)
 175   1              {
 176   2                  /* Disable Interrupt. */
 177   2              CyIntDisable(CAN_ISR_NUMBER);
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 4   

 178   2      
 179   2              /* Set the ISR to point to the CAN_ISR Interrupt. */
 180   2              (void) CyIntSetVector(CAN_ISR_NUMBER, & CAN_ISR);
 181   2      
 182   2              /* Set the priority. */
 183   2              CyIntSetPriority(CAN_ISR_NUMBER, CAN_ISR_PRIORITY);
 184   2      
 185   2                  if (CAN_SetPreScaler(CAN_BITRATE) == CYRET_SUCCESS)
 186   2                  {
 187   3                      if (CAN_SetArbiter(CAN_ARBITER) == CYRET_SUCCESS)
 188   3                      {
 189   4                          #if (!(CY_PSOC3 || CY_PSOC5))
                                      if (CAN_SetSwapDataEndianness(CAN_SWAP_DATA_END) == CYRET_SUCCESS)
                                  #endif /* (!(CY_PSOC3 || CY_PSOC5)) */
 192   4                              {
 193   5                                  if (CAN_SetTsegSample(CAN_CFG_REG_TSEG1,
 194   5                                      CAN_CFG_REG_TSEG2, CAN_CFG_REG_SJW,
 195   5                                      CAN_SAMPLING_MODE) == CYRET_SUCCESS)
 196   5                                  {
 197   6                                      if (CAN_SetRestartType(CAN_RESET_TYPE) == CYRET_SUCCESS)
 198   6                                      {
 199   7                                          if (CAN_SetEdgeMode(CAN_SYNC_EDGE) == CYRET_SUCCESS)
 200   7                                          {
 201   8                                              localResult = CYRET_SUCCESS;
 202   8                                          }
 203   7                                      }
 204   6                                  }
 205   5                              }
 206   4                      }
 207   3                  }
 208   2      
 209   2                  if (localResult == CYRET_SUCCESS)
 210   2                  {
 211   3                      if (CAN_RxTxBuffersConfig() == CYRET_SUCCESS)
 212   3                      {
 213   4                          /* Write IRQ Mask */
 214   4                          if (CAN_SetIrqMask(CAN_INIT_INTERRUPT_MASK) ==
 215   4                              CYRET_SUCCESS)
 216   4                          {
 217   5                              /* Set CAN Operation Mode to Active mode always */
 218   5                              #if (CY_PSOC3 || CY_PSOC5)
 219   5                                  CAN_CMD_REG.byte[0u] = CAN_INITIAL_MODE;
 220   5                                  if ((CAN_CMD_REG.byte[0u] & CAN_MODE_MASK) == 0u)
 221   5                              #else  /* CY_PSOC4 */
                                          CAN_CMD_REG &= (uint32) (~((uint32) CAN_OPMODE_FIELD_MASK));
                                          if ((CAN_CMD_REG & CAN_OPMODE_FIELD_MASK) == 0u)
                                      #endif /* CY_PSOC3 || CY_PSOC5 */
 225   5                                  {
 226   6                                      result = CYRET_SUCCESS;
 227   6                                  }
 228   5                          }
 229   4                      }
 230   3                  }
 231   2              }
 232   1      
 233   1          return (result);
 234   1      }
 235          
 236          
 237          /*******************************************************************************
 238          * Function Name: CAN_Enable
 239          ********************************************************************************
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 5   

 240          *
 241          * Summary:
 242          *  This function enables the CAN Component and ISR of CAN Component.
 243          *
 244          * Parameters:
 245          *  None.
 246          *
 247          * Return:
 248          *  The indication whether the register is written and verified.
 249          *   Define                             Description
 250          *    CYRET_SUCCESS                      The function passed successfully
 251          *    CAN_FAIL              The function failed
 252          *
 253          *******************************************************************************/
 254          uint8 CAN_Enable(void) 
 255          {
 256   1          uint32 timeout = CAN_MODE_STATE_RUN_TIMEOUT;
 257   1          uint8 result = CAN_FAIL;
 258   1      
 259   1          #if (CY_PSOC3 || CY_PSOC5)
 260   1              uint8 enableInterrupts;
 261   1      
 262   1              enableInterrupts = CyEnterCriticalSection();
 263   1      
 264   1              /* Enable CAN block in Active mode */
 265   1              CAN_PM_ACT_CFG_REG |= CAN_ACT_PWR_EN;
 266   1      
 267   1              /* Enable CAN block in Alternate Active (Standby) mode */
 268   1              CAN_PM_STBY_CFG_REG |= CAN_STBY_PWR_EN;
 269   1      
 270   1              CyExitCriticalSection(enableInterrupts);
 271   1          #endif /* CY_PSOC3 || CY_PSOC5 */
 272   1      
 273   1          /* Clear interrupts status */
 274   1          CY_SET_REG32(CAN_INT_SR_PTR, CAN_INIT_INTERRUPT_MASK);
 275   1          (void) CAN_GlobalIntEnable();
 276   1      
 277   1          /* Enable isr */
 278   1          CyIntEnable(CAN_ISR_NUMBER);
 279   1      
 280   1          /* Sets CAN controller to run mode */
 281   1          CY_SET_REG32(CAN_CMD_PTR, CY_GET_REG32(CAN_CMD_PTR) | CAN_MODE_MASK);
 282   1      
 283   1          /* Timeout for CAN state machine to switch mode to Run */
 284   1          while ((timeout != 0u) && ((CY_GET_REG32(CAN_CMD_PTR) & CAN_MODE_MASK) == 0u))
 285   1          {
 286   2              timeout--;
 287   2          }
 288   1      
 289   1          if (timeout != 0u)
 290   1          {
 291   2              result = CYRET_SUCCESS;
 292   2          }
 293   1      
 294   1          return (result);
 295   1      }
 296          
 297          
 298          /*******************************************************************************
 299          * FUNCTION NAME:   CAN_Start
 300          ********************************************************************************
 301          *
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 6   

 302          * Summary:
 303          *  This function sets CAN Component into the Run mode. Starts Rate Counter if
 304          *  polling mailboxes are available.
 305          *
 306          * Parameters:
 307          *  None.
 308          *
 309          * Return:
 310          *  The indication whether the register is written and verified.
 311          *   Define                             Description
 312          *    CYRET_SUCCESS                      The function passed successfully
 313          *    CAN_FAIL              The function failed
 314          *
 315          * Global variables:
 316          *  CAN_initVar - used to check the initial configuration, modified
 317          *  on the first function call.
 318          *
 319          * Reentrant:
 320          *  No.
 321          *
 322          *******************************************************************************/
 323          uint8 CAN_Start(void) 
 324          {
 325   1          uint8 result = CYRET_SUCCESS;
 326   1      
 327   1          if (CAN_initVar == 0u)
 328   1          {
 329   2              result = CAN_Init();
 330   2          }
 331   1      
 332   1          if (result == CYRET_SUCCESS)
 333   1          {
 334   2              CAN_initVar = 1u;
 335   2              result = CAN_Enable();
 336   2          }
 337   1      
 338   1          return (result);
 339   1      }
 340          
 341          
 342          /*******************************************************************************
 343          * FUNCTION NAME:   CAN_Stop
 344          ********************************************************************************
 345          *
 346          * Summary:
 347          *  This function sets CAN Component into the Stop mode.
 348          *
 349          * Parameters:
 350          *  None.
 351          *
 352          * Return:
 353          *  The indication whether the register is written and verified.
 354          *   Define                             Description
 355          *    CYRET_SUCCESS                      The function passed successfully
 356          *    CAN_FAIL              The function failed
 357          *
 358          * Side Effects:
 359          *  Disable power to CAN Core in case of PSoC 3/5.
 360          *  Pending message in the Tx buffer of PSoC 3/5 will not be aborted on calling
 361          *  the CAN_Stop() API. User has to abort all pending messages
 362          *  before calling the CAN_Stop() function to make sure that the
 363          *  block stops all the message transmission immediately.
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 7   

 364          *
 365          *******************************************************************************/
 366          uint8 CAN_Stop(void) 
 367          {
 368   1          uint32 timeout = CAN_MODE_STATE_STOP_TIMEOUT;
 369   1          uint8 result = CAN_FAIL;
 370   1      
 371   1          #if (CY_PSOC3 || CY_PSOC5)
 372   1              uint8 enableInterrupts;
 373   1          #endif /* CY_PSOC3 || CY_PSOC5 */
 374   1      
 375   1          /* Set CAN controller to stop mode */
 376   1          CY_SET_REG32(CAN_CMD_PTR, (CY_GET_REG32(CAN_CMD_PTR) &
 377   1                                                  ((uint32) (~((uint32)CAN_MODE_MASK)))));
 378   1      
 379   1          /* Timeout for CAN state machine to switch mode to Stop */
 380   1          while ((timeout != 0u) && ((CY_GET_REG32(CAN_CMD_PTR) & CAN_MODE_MASK) != 0u))
 381   1          {
 382   2              timeout--;
 383   2          }
 384   1      
 385   1          /* Verify that bit is cleared */
 386   1          if (timeout != 0u)
 387   1          {
 388   2              result = CYRET_SUCCESS;
 389   2      
 390   2              /* Disable isr */
 391   2          CyIntDisable(CAN_ISR_NUMBER);
 392   2      
 393   2              #if (CY_PSOC3 || CY_PSOC5)
 394   2                  enableInterrupts = CyEnterCriticalSection();
 395   2      
 396   2                  /* Disable CAN block in Active mode */
 397   2                  CAN_PM_ACT_CFG_REG &= (uint8) (~CAN_ACT_PWR_EN);
 398   2      
 399   2                  /* Disable CAN block in Alternate Active (Standby) mode template */
 400   2                  CAN_PM_STBY_CFG_REG &= (uint8) (~CAN_STBY_PWR_EN);
 401   2      
 402   2                  CyExitCriticalSection(enableInterrupts);
 403   2              #endif /* CY_PSOC3 || CY_PSOC5 */
 404   2          }
 405   1      
 406   1          return (result);
 407   1      }
 408          
 409          
 410          /*******************************************************************************
 411          * FUNCTION NAME:   CAN_GlobalIntEnable
 412          ********************************************************************************
 413          *
 414          * Summary:
 415          *  This function enables Global Interrupts from CAN Core.
 416          *
 417          * Parameters:
 418          *  None.
 419          *
 420          * Return:
 421          *  The indication whether the register is written and verified.
 422          *   Define                             Description
 423          *    CYRET_SUCCESS                      The function passed successfully
 424          *    CAN_FAIL              The function failed
 425          *
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 8   

 426          *******************************************************************************/
 427          uint8 CAN_GlobalIntEnable(void) 
 428          {
 429   1          uint8 result = CAN_FAIL;
 430   1      
 431   1          #if (CY_PSOC3 || CY_PSOC5)
 432   1              CAN_INT_EN_REG.byte[0u] |= CAN_GLOBAL_INT_MASK;
 433   1      
 434   1              /* Verify that bit is set */
 435   1              if ((CAN_INT_EN_REG.byte[0u] & CAN_GLOBAL_INT_MASK) != 0u)
 436   1              {
 437   2                  result = CYRET_SUCCESS;
 438   2              }
 439   1          #else  /* CY_PSOC4 */
                      CAN_INT_EN_REG |= CAN_GLOBAL_INT_MASK;
                      /* Verify that bit is set */
                      if ((CAN_INT_EN_REG & CAN_GLOBAL_INT_MASK) != 0u)
                      {
                          result = CYRET_SUCCESS;
                      }
                  #endif /* CY_PSOC3 || CY_PSOC5 */
 447   1      
 448   1          return (result);
 449   1      }
 450          
 451          
 452          /*******************************************************************************
 453          * FUNCTION NAME:   CAN_GlobalIntDisable
 454          ********************************************************************************
 455          *
 456          * Summary:
 457          *  This function disables Global Interrupts from CAN Core.
 458          *
 459          * Parameters:
 460          *  None.
 461          *
 462          * Return:
 463          *  The indication whether the register is written and verified.
 464          *   Define                             Description
 465          *    CYRET_SUCCESS                      The function passed successfully
 466          *    CAN_FAIL              The function failed
 467          *
 468          *******************************************************************************/
 469          uint8 CAN_GlobalIntDisable(void) 
 470          {
 471   1          uint8 result = CAN_FAIL;
 472   1      
 473   1          #if (CY_PSOC3 || CY_PSOC5)
 474   1              CAN_INT_EN_REG.byte[0u] &= (uint8) (~CAN_GLOBAL_INT_MASK);
 475   1      
 476   1              /* Verify that bit is cleared */
 477   1              if ((CAN_INT_EN_REG.byte[0u] & CAN_GLOBAL_INT_MASK) == 0u)
 478   1              {
 479   2                  result = CYRET_SUCCESS;
 480   2              }
 481   1          #else  /* CY_PSOC4 */
                      CAN_INT_EN_REG &= (uint32) (~((uint32) CAN_GLOBAL_INT_MASK));
              
                      /* Verify that bit is cleared */
                      if ((CAN_INT_EN_REG & CAN_GLOBAL_INT_MASK) == 0u)
                      {
                          result = CYRET_SUCCESS;
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 9   

                      }
                  #endif /* CY_PSOC3 || CY_PSOC5 */
 490   1      
 491   1          return (result);
 492   1      }
 493          
 494          
 495          /*******************************************************************************
 496          * FUNCTION NAME:   CAN_SetPreScaler
 497          ********************************************************************************
 498          *
 499          * Summary:
 500          *  This function sets PreScaler for generating the time quantum which defines
 501          *  the time quanta. The values between 0x0 and 0x7FFF are valid.
 502          *
 503          * Parameters:
 504          *  bitrate: PreScaler value.
 505          *   Value           Description
 506          *    0               One time quantum equals 1 clock cycle
 507          *    1               One time quantum equals 2 clock cycles
 508          *    ...             ...
 509          *    32767           One time quantum equals 32768 clock cycles
 510          *
 511          * Return:
 512          *  The indication whether the register is written and verified.
 513          *   Define                             Description
 514          *    CYRET_SUCCESS                      The function passed successfully
 515          *    CAN_FAIL              The function failed
 516          *    CAN_OUT_OF_RANGE      The function parameter is out of range
 517          *
 518          *******************************************************************************/
 519          uint8 CAN_SetPreScaler(uint16 bitrate) 
 520          {
 521   1          uint8 result = CAN_OUT_OF_RANGE;
 522   1      
 523   1          if (bitrate <= CAN_BITRATE_MASK)
 524   1          {
 525   2              result = CAN_FAIL;
 526   2      
 527   2              #if (CY_PSOC3 || CY_PSOC5)
 528   2                  /* Set prescaler */
 529   2                  CY_SET_REG16((reg16 *) (&CAN_CFG_REG.byte[2u]), bitrate);
 530   2      
 531   2                  /* Verify that prescaler is set */
 532   2                  if (CY_GET_REG16((reg16 *) (&CAN_CFG_REG.byte[2u])) == bitrate)
 533   2                  {
 534   3                      result = CYRET_SUCCESS;
 535   3                  }
 536   2              #else  /* CY_PSOC4 */
                          /* Set prescaler */
                          CAN_CFG_REG = (CAN_CFG_REG & (uint32) (~CAN_BITRATE_MASK_SHIFTED)) |
                          (uint32) ((uint32) bitrate << CAN_BITRATE_SHIFT);
              
                          /* Verify that prescaler is set */
                          if ((CAN_CFG_REG & CAN_BITRATE_MASK_SHIFTED) ==
                             ((uint32) ((uint32) bitrate << CAN_BITRATE_SHIFT)))
                          {
                              result = CYRET_SUCCESS;
                          }
                      #endif /* CY_PSOC3 || CY_PSOC5 */
 548   2          }
 549   1      
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 10  

 550   1          return (result);
 551   1      }
 552          
 553          
 554          /*******************************************************************************
 555          * FUNCTION NAME:   CAN_SetArbiter
 556          ********************************************************************************
 557          *
 558          * Summary:
 559          *  This function sets the arbitration type for transmit mailboxes. The types of
 560          *  the arbiters are Round Robin and Fixed Priority. Values 0 and 1 are valid.
 561          *
 562          * Parameters:
 563          *  arbiter: The arbitration type for transmit mailboxes.
 564          *   Value                              Description
 565          *    CAN_ROUND_ROBIN       The Round Robin arbitration
 566          *    CAN_FIXED_PRIORITY    The Fixed Priority arbitration.
 567          *
 568          * Return:
 569          *  The indication whether the register is written and verified.
 570          *   Define                             Description
 571          *    CYRET_SUCCESS                      The function passed successfully
 572          *    CAN_FAIL              The function failed
 573          *
 574          *******************************************************************************/
 575          uint8 CAN_SetArbiter(uint8 arbiter) 
 576          {
 577   1          uint8 result = CAN_FAIL;
 578   1      
 579   1          #if (CY_PSOC3 || CY_PSOC5)
 580   1              if (arbiter == CAN_ROUND_ROBIN)
 581   1              {
 582   2                  CAN_CFG_REG.byte[1u] &= (uint8) (~CAN_ARBITRATION_MASK);
 583   2      
 584   2                  /* Verify that bit is cleared */
 585   2                  if ((CAN_CFG_REG.byte[1u] & CAN_ARBITRATION_MASK) == 0u)
 586   2                  {
 587   3                      result = CYRET_SUCCESS;
 588   3                  }
 589   2              }
 590   1              else    /* Fixed Priority */
 591   1              {
 592   2                  CAN_CFG_REG.byte[1u] |= CAN_ARBITRATION_MASK;
 593   2      
 594   2                  /* Verify that bit is set */
 595   2                  if ((CAN_CFG_REG.byte[1u] & CAN_ARBITRATION_MASK) != 0u)
 596   2                  {
 597   3                      result = CYRET_SUCCESS;
 598   3                  }
 599   2              }
 600   1          #else  /* CY_PSOC4 */
                      if (arbiter == CAN_ROUND_ROBIN)
                      {
                          CAN_CFG_REG &= (uint32) (~CAN_ARBITRATION_MASK);
              
                          /* Verify that bit is cleared */
                          if ((CAN_CFG_REG & CAN_ARBITRATION_MASK) == 0u)
                          {
                              result = CYRET_SUCCESS;
                          }
                      }
                      else    /* Fixed priority */
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 11  

                      {
                          CAN_CFG_REG |= CAN_ARBITRATION_MASK;
              
                          /* Verify that bit is set */
                          if ((CAN_CFG_REG & CAN_ARBITRATION_MASK) != 0u)
                          {
                              result = CYRET_SUCCESS;
                          }
                      }
                  #endif /* CY_PSOC3 || CY_PSOC5 */
 622   1      
 623   1          return (result);
 624   1      }
 625          
 626          
 627          /*******************************************************************************
 628          * FUNCTION NAME: CAN_SetTsegSample
 629          ********************************************************************************
 630          *
 631          * Summary:
 632          *  This function configures: Time segment 1, Time segment 2, Sampling Mode
 633          *  and Synchronization Jump Width.
 634          *
 635          * Parameters:
 636          *  cfgTseg1: The length of time segment 1, values between 0x2 and 0xF are valid;
 637          *  cfgTseg2: The length of time segment 2, values between 0x1 and 0x7 are valid;
 638          *  sjw: Synchronization Jump Width, value between 0x0 and 0x3 are valid;
 639          *  sm: Sampling Mode.
 640          *   Define                               Description
 641          *   CAN_ONE_SAMPLE_POINT     One sampling point is used
 642          *   CAN_THREE_SAMPLE_POINTS  Three sampling points are used
 643          *
 644          * Return:
 645          *  The indication whether the register is written and verified.
 646          *   Define                             Description
 647          *    CYRET_SUCCESS                      The function passed successfully
 648          *    CAN_FAIL              The function failed
 649          *    CAN_OUT_OF_RANGE      The function parameter is out of range
 650          *
 651          *******************************************************************************/
 652          uint8 CAN_SetTsegSample(uint8 cfgTseg1, uint8 cfgTseg2, uint8 sjw, uint8 sm)
 653                                               
 654          {
 655   1          uint8 result = CAN_OUT_OF_RANGE;
 656   1          uint8 cfgTemp;
 657   1      
 658   1          if ((cfgTseg1 >= CAN_CFG_REG_TSEG1_LOWER_LIMIT) && (cfgTseg1 <=
 659   1               CAN_CFG_REG_TSEG1_UPPER_LIMIT))
 660   1          {
 661   2              if (((cfgTseg2 >= CAN_CFG_REG_TSEG2_LOWER_LIMIT) &&
 662   2                   (cfgTseg2 <= CAN_CFG_REG_TSEG2_UPPER_LIMIT)) || ((sm == CAN_ONE_SAMPLE_POINT) &&
 663   2                   (cfgTseg2 == CAN_CFG_REG_TSEG2_EXCEPTION)))
 664   2              {
 665   3                  if ((sjw <= CAN_CFG_REG_SJW_LOWER_LIMIT) && (sjw <= cfgTseg1) && (sjw <= cfgTseg2))
 666   3                  {
 667   4                      result = CAN_FAIL;
 668   4      
 669   4                      #if (CY_PSOC3 || CY_PSOC5)
 670   4                          cfgTemp = CAN_CFG_REG.byte[1];
 671   4                          cfgTemp &= (uint8) (~CAN_CFG_REG_TSEG1_MASK);
 672   4                          cfgTemp |= cfgTseg1;
 673   4      
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 12  

 674   4                          /* Write register byte 1 */
 675   4                          CAN_CFG_REG.byte[1u] = cfgTemp;
 676   4      
 677   4                          /* Verify 1st byte of CAN_CFG_REG register */
 678   4                          if (CAN_CFG_REG.byte[1u] == cfgTemp)
 679   4                          {
 680   5                              cfgTemp = 0u;
 681   5                              /* Set appropriate bits */
 682   5                              if (sm != CAN_ONE_SAMPLE_POINT)
 683   5                              {
 684   6                                  cfgTemp = CAN_SAMPLE_MODE_MASK;
 685   6                              }
 686   5                              cfgTemp |= ((uint8) (cfgTseg2 << CAN_CFG_REG_TSEG2_SHIFT)) |
 687   5                                         ((uint8) (sjw << CAN_CFG_REG_SJW_SHIFT));
 688   5      
 689   5                              /* Write register byte 0 */
 690   5                              CAN_CFG_REG.byte[0u] = cfgTemp;
 691   5      
 692   5                              /* Verify 1st byte of CAN_CFG_REG register */
 693   5                              if (CAN_CFG_REG.byte[0u] == cfgTemp)
 694   5                              {
 695   6                                  result = CYRET_SUCCESS;
 696   6                              }
 697   5                          }
 698   4                      #else  /* CY_PSOC4 */
                                  cfgTemp = (uint8) (CAN_CFG_REG >> CAN_CFG_REG_TSEG1_SHIFT);
                                  cfgTemp &= (uint8) (~CAN_CFG_REG_TSEG1_MASK);
                                  cfgTemp |= cfgTseg1;
              
                                  /* Write register byte 1 */
                                  CAN_CFG_REG =
                                  (CAN_CFG_REG & (uint32) (~((uint32) ((uint32) CAN_CFG_REG_TSEG1_MASK <<
                                  CAN_CFG_REG_TSEG1_SHIFT)))) |
                                  (uint32) ((uint32) cfgTemp << CAN_CFG_REG_TSEG1_SHIFT);
              
                                  /* Verify 1st byte of CAN_CFG_REG register */
                                  if ((CAN_CFG_REG & (uint32) ((uint32) CAN_CFG_REG_TSEG1_MASK <<
                                     CAN_CFG_REG_TSEG1_SHIFT)) == (uint32) ((uint32) ((uint32) cfgTemp &
                                     CAN_CFG_REG_TSEG1_MASK) << CAN_CFG_REG_TSEG1_SHIFT))
                                  {
                                      cfgTemp = 0u;
                                      /* Set appropriate bits */
                                      if (sm != CAN_ONE_SAMPLE_POINT)
                                      {
                                          cfgTemp = CAN_SAMPLE_MODE_MASK;
                                      }
                                      cfgTemp |= ((uint8) (cfgTseg2 << CAN_CFG_REG_TSEG2_SHIFT)) |
                                                 ((uint8) (sjw << CAN_CFG_REG_SJW_SHIFT));
              
                                      /* Write register byte 0 */
                                      CAN_CFG_REG = (CAN_CFG_REG &
                                      (uint32) (~((uint32) (CAN_CFG_REG_TSEG2_MASK | CAN_CFG_REG_SJW_MASK |
                                      CAN_SAMPLE_MODE_MASK)))) | cfgTemp;
              
                                      /* Verify 1st byte of CAN_CFG_REG register */
                                      if ((CAN_CFG_REG & (CAN_CFG_REG_TSEG2_MASK |
                                         CAN_CFG_REG_SJW_MASK | CAN_SAMPLE_MODE_MASK)) == cfgTemp)
                                      {
                                          result = CYRET_SUCCESS;
                                      }
                                  }
                              #endif /* CY_PSOC3 || CY_PSOC5 */
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 13  

 736   4                  }
 737   3              }
 738   2          }
 739   1      
 740   1          return (result);
 741   1      }
 742          
 743          
 744          /*******************************************************************************
 745          * FUNCTION NAME:   CAN_SetRestartType
 746          ********************************************************************************
 747          *
 748          * Summary:
 749          *  This function sets the Reset type. The types of Reset are Automatic and
 750          *  Manual. Manual Reset is the recommended setting.
 751          *
 752          * Parameters:
 753          *  reset: Reset Type.
 754          *   Define                             Description
 755          *    CAN_MANUAL_RESTART    After Bus-Off, CAN must be restarted
 756          *                                       manually. This is the recommended
 757          *                                       setting.
 758          *    CAN_AUTO_RESTART      After Bus-Off, CAN restarts
 759          *                                       automatically after 128 groups of 11
 760          *                                       recessive bits.
 761          *
 762          * Return:
 763          *  The indication whether the register is written and verified.
 764          *   Define                             Description
 765          *    CYRET_SUCCESS                      The function passed successfully
 766          *    CAN_FAIL              The function failed
 767          *
 768          *******************************************************************************/
 769          uint8 CAN_SetRestartType(uint8 reset) 
 770          {
 771   1          uint8 result = CAN_FAIL;
 772   1      
 773   1          #if (CY_PSOC3 || CY_PSOC5)
 774   1              if (reset == CAN_MANUAL_RESTART)
 775   1              {
 776   2                  CAN_CFG_REG.byte[0u] &= (uint8) (~CAN_RESET_MASK);
 777   2      
 778   2                  /* Verify that bit is cleared */
 779   2                  if ((CAN_CFG_REG.byte[0u] & CAN_RESET_MASK) == 0u)
 780   2                  {
 781   3                      result = CYRET_SUCCESS;
 782   3                  }
 783   2              }
 784   1              else    /* Automatic restart */
 785   1              {
 786   2                  CAN_CFG_REG.byte[0u] |= CAN_RESET_MASK;
 787   2      
 788   2                  /* Verify that bit is set */
 789   2                  if ((CAN_CFG_REG.byte[0u] & CAN_RESET_MASK) != 0u)
 790   2                  {
 791   3                      result = CYRET_SUCCESS;
 792   3                  }
 793   2              }
 794   1          #else  /* CY_PSOC4 */
                      if (reset == CAN_MANUAL_RESTART)
                      {
                          CAN_CFG_REG &= (uint32) (~((uint32) CAN_RESET_MASK));
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 14  

              
                          /* Verify that bit is cleared */
                          if ((CAN_CFG_REG & CAN_RESET_MASK) == 0u)
                          {
                              result = CYRET_SUCCESS;
                          }
                      }
                      else    /* Automatic restart */
                      {
                          CAN_CFG_REG |= CAN_RESET_MASK;
              
                          /* Verify that bit is set */
                          if ((CAN_CFG_REG & CAN_RESET_MASK) != 0u)
                          {
                              result = CYRET_SUCCESS;
                          }
                      }
                  #endif /* CY_PSOC3 || CY_PSOC5 */
 816   1      
 817   1          return (result);
 818   1      }
 819          
 820          
 821          /*******************************************************************************
 822          * FUNCTION NAME:   CAN_SetEdgeMode
 823          ********************************************************************************
 824          *
 825          * Summary:
 826          *  This function sets Edge Mode. The modes are 'R' to 'D'(Recessive to Dominant)
 827          *  and Both edges are used.
 828          *
 829          * Parameters:
 830          *  edge: Edge Mode.
 831          *   Define                             Description
 832          *    CAN_EDGE_R_TO_D       The edge from R to D is used for
 833          *                                       synchronization
 834          *    CAN_BOTH_EDGES        Both edges are used
 835          *
 836          * Return:
 837          *  The indication whether the register is written and verified.
 838          *   Define                             Description
 839          *    CYRET_SUCCESS                      The function passed successfully
 840          *    CAN_FAIL              The function failed
 841          *
 842          *******************************************************************************/
 843          uint8 CAN_SetEdgeMode(uint8 edge) 
 844          {
 845   1          uint8 result = CAN_FAIL;
 846   1      
 847   1          #if (CY_PSOC3 || CY_PSOC5)
 848   1              if (edge == CAN_EDGE_R_TO_D)
 849   1              {
 850   2                  /* Recessive to Dominant is used for synchronization */
 851   2                  CAN_CFG_REG.byte[0u] &= (uint8) (~CAN_EDGE_MODE_MASK);
 852   2      
 853   2                  /* Verify that bit is cleared */
 854   2                  if ((CAN_CFG_REG.byte[0u] & CAN_EDGE_MODE_MASK) == 0u)
 855   2                  {
 856   3                      result = CYRET_SUCCESS;
 857   3                  }
 858   2              }
 859   1              else
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 15  

 860   1              {
 861   2                  /* Both edges to be used */
 862   2                  CAN_CFG_REG.byte[0u] |= CAN_EDGE_MODE_MASK;
 863   2      
 864   2                  /* Verify that bit is set */
 865   2                  if ((CAN_CFG_REG.byte[0u] & CAN_EDGE_MODE_MASK) != 0u)
 866   2                  {
 867   3                      result = CYRET_SUCCESS;
 868   3                  }
 869   2              }
 870   1          #else  /* CY_PSOC4 */
                      if (edge == CAN_EDGE_R_TO_D)
                      {
                          /* Recessive to Dominant is used for synchronization */
                          CAN_CFG_REG &= (uint32) (~((uint32) CAN_EDGE_MODE_MASK));
              
                          /* Verify that bit is cleared */
                          if ((CAN_CFG_REG & CAN_EDGE_MODE_MASK) == 0u)
                          {
                              result = CYRET_SUCCESS;
                          }
                      }
                      else
                      {
                          /* Both edges to be used */
                          CAN_CFG_REG |= CAN_EDGE_MODE_MASK;
              
                          /* Verify that bit is set */
                          if ((CAN_CFG_REG & CAN_EDGE_MODE_MASK) != 0u)
                          {
                              result = CYRET_SUCCESS;
                          }
                      }
                  #endif /* CY_PSOC3 || CY_PSOC5 */
 894   1      
 895   1          return (result);
 896   1      }
 897          
 898          
 899          /*******************************************************************************
 900          * FUNCTION NAME:   CAN_SetOpMode
 901          ********************************************************************************
 902          *
 903          * Summary:
 904          *  This function sets Operation Mode.
 905          *
 906          * Parameters:
 907          *  opMode: Operation Mode value.
 908          *   Define                              Description
 909          *    CAN_STOP_MODE          The CAN controller is in the Stop mode
 910          *    CAN_ACTIVE_RUN_MODE    The CAN controller is in the Active
 911          *                                        mode
 912          *    CAN_LISTEN_ONLY_MODE   The CAN controller is in the Listen
 913          *                                        Only mode: The output is held at the
 914          *                                        'R' level.
 915          *    CAN_INTERNAL_LOOP_BACK The CAN controller is in the Internal
 916          *                                        Loopback mode. This mode is used for
 917          *                                        the testing purpose and the transmitted
 918          *                                        transactions are internally routed
 919          *                                        back to the receiver logic and
 920          *                                        processed by the controller in this
 921          *                                        mode. Not available for PSoC3/5.
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 16  

 922          *    CAN_EXTERNAL_LOOP_BACK This mode is used for the testing
 923          *                                        purpose by connecting Tx and Rx lines
 924          *                                        externally. The transmitted messages
 925          *                                        are received back and processed by the
 926          *                                        CAN controller in this mode.
 927          *                                        Not available for PSoC3/5.
 928          * Return:
 929          *  The indication whether the register is written and verified.
 930          *   Define                             Description
 931          *    CYRET_SUCCESS                      The function passed successfully
 932          *    CAN_FAIL              The function failed
 933          *
 934          * Side Effects:
 935          *  For PSoC 4 device family the function re-initializes the CAN registers.
 936          *
 937          *******************************************************************************/
 938          uint8 CAN_SetOpMode(uint8 opMode) 
 939          {
 940   1          #if (CY_PSOC3 || CY_PSOC5)
 941   1              uint32 timeout;
 942   1          #endif /* CY_PSOC3 || CY_PSOC5 */
 943   1          uint8 result = CAN_FAIL;
 944   1          uint8 runState = CAN_STOP_MODE;
 945   1      
 946   1          #if (CY_PSOC3 || CY_PSOC5)
 947   1              if (((CAN_CMD_REG.byte[0u] & CAN_ACTIVE_RUN_MODE) != 0u) ||
 948   1                  (opMode == CAN_ACTIVE_RUN_MODE))
 949   1              {
 950   2                  runState = CAN_ACTIVE_RUN_MODE;
 951   2              }
 952   1      
 953   1              /* Set CAN to the Stop Mode */
 954   1              CAN_CMD_REG.byte[0u] = CAN_STOP_MODE;
 955   1      
 956   1              /* Timeout for CAN state machine to switch mode to Stop */
 957   1              for (timeout = CAN_MODE_STATE_STOP_TIMEOUT;
 958   1                  (timeout != 0u) && ((CAN_CMD_REG.byte[0u] & CAN_ACTIVE_RUN_MODE) != 0u);
 959   1                   timeout--)
 960   1              {
 961   2              }
 962   1      
 963   1              if (timeout != 0u)
 964   1              {
 965   2                  result = CYRET_SUCCESS;
 966   2              }
 967   1      
 968   1              if ((result == CYRET_SUCCESS) && (opMode != CAN_STOP_MODE))
 969   1              {
 970   2                  if (opMode == CAN_LISTEN_ONLY_MODE)
 971   2                  {
 972   3                      CAN_CMD_REG.byte[0u] = CAN_LISTEN_ONLY_MODE;
 973   3                  }
 974   2      
 975   2                  if (runState == CAN_ACTIVE_RUN_MODE)
 976   2                  {
 977   3                      CAN_CMD_REG.byte[0u] |= CAN_ACTIVE_RUN_MODE;
 978   3      
 979   3                      /* Timeout for CAN state machine to switch mode to Run */
 980   3                      for (timeout = CAN_MODE_STATE_RUN_TIMEOUT;
 981   3                          (timeout != 0u) && ((CAN_CMD_REG.byte[0u] & CAN_MODE_MASK) == 0u);
 982   3                           timeout--)
 983   3                      {
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 17  

 984   4                      }
 985   3      
 986   3                      if (timeout == 0u)
 987   3                      {
 988   4                          result = CAN_FAIL;
 989   4                      }
 990   3                  }
 991   2              }
 992   1          #else  /* CY_PSOC4 */
                      if (((CAN_CMD_REG & CAN_MODE_MASK) != 0u) ||
                          (opMode == CAN_ACTIVE_RUN_MODE))
                      {
                          runState = CAN_ACTIVE_RUN_MODE;
                      }
              
                      /* Sets CAN Component into the Stop mode */
                      if (CAN_Stop() == CYRET_SUCCESS)
                      {
                          /* Disable CAN IP Block to reset configuration before sets Operation Mode */
                          CAN_CNTL_REG = (uint32) (~CAN_IP_ENABLE);
              
                          /* Enable CAN IP Block */
                          CAN_CNTL_REG = CAN_IP_ENABLE;
              
                          result = CAN_Init();
              
                          if ((result == CYRET_SUCCESS) && (opMode != CAN_STOP_MODE))
                          {
                              if (opMode != CAN_ACTIVE_RUN_MODE)
                              {
                                  /* Set CAN Operation Mode */
                                  CAN_CMD_REG |= opMode;
                              }
              
                              if (runState == CAN_ACTIVE_RUN_MODE)
                              {
                                  /* Enable component's operation */
                                  result = CAN_Enable();
                              }
                          }
                      }
                  #endif /* CY_PSOC3 || CY_PSOC5 */
1026   1      
1027   1          return (result);
1028   1      }
1029          
1030          
1031          /*******************************************************************************
1032          * FUNCTION NAME:   CAN_RXRegisterInit
1033          ********************************************************************************
1034          *
1035          * Summary:
1036          *  This function writes only receive CAN registers.
1037          *
1038          * Parameters:
1039          *  regAddr: The pointer to a CAN receive register;
1040          *  config:  The value that will be written in the register.
1041          *
1042          * Return:
1043          *  The indication whether the register is written and verified.
1044          *   Define                             Description
1045          *    CYRET_SUCCESS                      The function passed successfully
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 18  

1046          *    CAN_FAIL              The function failed
1047          *    CAN_OUT_OF_RANGE      The function parameter is out of range
1048          *
1049          *******************************************************************************/
1050          uint8 CAN_RXRegisterInit(reg32 *regAddr, uint32 config)
1051                                                
1052          {
1053   1          uint8 result = CAN_OUT_OF_RANGE;
1054   1      
1055   1          if ((((uint32) regAddr & CAN_REG_ADDR_MASK) >=
1056   1              ((uint32) CAN_RX_FIRST_REGISTER_PTR & CAN_REG_ADDR_MASK)) &&
1057   1              ((((uint32) regAddr & CAN_REG_ADDR_MASK)) <=
1058   1              ((uint32) CAN_RX_LAST_REGISTER_PTR & CAN_REG_ADDR_MASK)))
1059   1          {
1060   2              result = CAN_FAIL;
1061   2      
1062   2              if ((((uint32) regAddr & CAN_REG_ADDR_MASK) % CAN_RX_CMD_REG_WIDTH) == 0u)
1063   2              {
1064   3                  config |= CAN_RX_WPN_SET;
1065   3      
1066   3          /* Disable isr */
1067   3          CyIntDisable(CAN_ISR_NUMBER);
1068   3      
1069   3                  /* Write defined RX CMD registers */
1070   3                  CY_SET_REG32(regAddr, config);
1071   3      
1072   3          /* Enable isr */
1073   3          CyIntEnable(CAN_ISR_NUMBER);
1074   3      
1075   3                  /* Verify register */
1076   3                  if ((CY_GET_REG32(regAddr) & CAN_RX_READ_BACK_MASK) ==
1077   3                      (config & CAN_RX_READ_BACK_MASK))
1078   3                  {
1079   4                      result = CYRET_SUCCESS;
1080   4                  }
1081   3              }
1082   2              /* All registers except RX CMD*/
1083   2              else
1084   2              {
1085   3          /* Disable isr */
1086   3          CyIntDisable(CAN_ISR_NUMBER);
1087   3      
1088   3                  /* Write defined CAN receive register */
1089   3                  CY_SET_REG32(regAddr, config);
1090   3      
1091   3          /* Enable isr */
1092   3          CyIntEnable(CAN_ISR_NUMBER);
1093   3      
1094   3                  /* Verify register */
1095   3                  if (CY_GET_REG32(regAddr) == config)
1096   3                  {
1097   4                      result = CYRET_SUCCESS;
1098   4                  }
1099   3              }
1100   2          }
1101   1      
1102   1          return (result);
1103   1      }
1104          
1105          
1106          /*******************************************************************************
1107          * FUNCTION NAME:   CAN_SetIrqMask
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 19  

1108          ********************************************************************************
1109          *
1110          * Summary:
1111          *  This function sets to enable/disable particular interrupt sources. Interrupt
1112          *  Mask directly write to the CAN Interrupt Enable register. A particular
1113          *  interrupt source is enabled by setting its respective flag to 1.
1114          *
1115          * Parameters:
1116          *  mask: Interrupt enable/disable request. 1 bit per interrupt source.
1117          *   Define                                    Description
1118          *    CAN_GLOBAL_INT_ENABLE        Global Interrupt Enable Flag
1119          *    CAN_ARBITRATION_LOST_ENABLE  Arbitration Loss Interrupt Enable
1120          *    CAN_OVERLOAD_ERROR_ENABLE    Overload Interrupt Enable
1121          *    CAN_BIT_ERROR_ENABLE         Bit Error Interrupt Enable
1122          *    CAN_STUFF_ERROR_ENABLE       Stuff Error Interrupt Enable
1123          *    CAN_ACK_ERROR_ENABLE         Ack Error Interrupt Enable
1124          *    CAN_FORM_ERROR_ENABLE        Form Error Interrupt Enable
1125          *    CAN_CRC_ERROR_ENABLE         CRC Error Interrupt Enable
1126          *    CAN_BUS_OFF_ENABLE           Bus-Off State Interrupt Enable
1127          *    CAN_RX_MSG_LOST_ENABLE       Rx Msg Loss Interrupt Enable
1128          *    CAN_TX_MESSAGE_ENABLE        Tx Msg Sent Interrupt Enable
1129          *    CAN_RX_MESSAGE_ENABLE        Msg Received Interrupt Enable
1130          *    CAN_RTR_MESSAGE_ENABLE       RTR Auto-reply Interrupt Enable
1131          *    CAN_STUCK_AT_ZERO_ENABLE     Stuck at dominant error Interrupt
1132          *                                              Enable
1133          *    CAN_SST_FAILURE_ENABLE       SST failure Interrupt Enable
1134          *
1135          * Return:
1136          *  The indication whether the register is written and verified.
1137          *   Define                             Description
1138          *    CYRET_SUCCESS                      The function passed successfully
1139          *    CAN_FAIL              The function failed
1140          *
1141          *******************************************************************************/
1142          uint8 CAN_SetIrqMask(uint16 mask) 
1143          {
1144   1          uint8 result = CAN_FAIL;
1145   1      
1146   1          #if (CY_PSOC3 || CY_PSOC5)
1147   1              /* Write byte 0 and 1 of CAN_INT_EN_REG register */
1148   1              CY_SET_REG16((reg16 *) (&CAN_INT_EN_REG), mask);
1149   1      
1150   1              /* Verify CAN_INT_EN_REG register */
1151   1              if (CY_GET_REG16((reg16 *) (&CAN_INT_EN_REG)) == mask)
1152   1              {
1153   2                  result = CYRET_SUCCESS;
1154   2              }
1155   1          #else  /* CY_PSOC4 */
                      /* Write byte 0 and 1 of CAN_INT_EN_REG register */
                      CAN_INT_EN_REG = mask;
              
                      /* Verify CAN_INT_EN_REG register */
                      if ((CAN_INT_EN_REG & CAN_REG_ADDR_MASK) == mask)
                      {
                          result = CYRET_SUCCESS;
                      }
                  #endif /* CY_PSOC3 || CY_PSOC5 */
1165   1      
1166   1          return (result);
1167   1      }
1168          
1169          
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 20  

1170          /*******************************************************************************
1171          * FUNCTION NAME:   CAN_GetTXErrorFlag
1172          ********************************************************************************
1173          *
1174          * Summary:
1175          *  This function returns the bit that indicates if the number of TX errors
1176          *  exceeds 0x60.
1177          *
1178          * Parameters:
1179          *  None.
1180          *
1181          * Return:
1182          *  The indication whether the number of TX errors exceeds 0x60.
1183          *
1184          *******************************************************************************/
1185          uint8 CAN_GetTXErrorFlag(void) 
1186          {
1187   1          #if (CY_PSOC3 || CY_PSOC5)
1188   1              /* Get state of transmit error flag */
1189   1              return (((CAN_ERR_SR_REG.byte[2u] & CAN_TX_ERROR_FLAG_MASK) ==
1190   1                        CAN_TX_ERROR_FLAG_MASK) ? 1u : 0u);
1191   1          #else  /* CY_PSOC4 */
                      /* Get state of transmit error flag */
                      return (((CAN_ERR_SR_REG & CAN_TX_ERROR_FLAG_MASK) ==
                                CAN_TX_ERROR_FLAG_MASK) ? 1u : 0u);
                  #endif /* CY_PSOC3 || CY_PSOC5 */
1196   1      
1197   1      }
1198          
1199          
1200          /*******************************************************************************
1201          * FUNCTION NAME:   CAN_GetRXErrorFlag
1202          ********************************************************************************
1203          *
1204          * Summary:
1205          *  This function returns the bit that indicates if the number of RX errors
1206          *  exceeds 0x60.
1207          *
1208          * Parameters:
1209          *  None.
1210          *
1211          * Return:
1212          *  The indication whether the number of TX errors exceeds 0x60.
1213          *
1214          *******************************************************************************/
1215          uint8 CAN_GetRXErrorFlag(void) 
1216          {
1217   1          #if (CY_PSOC3 || CY_PSOC5)
1218   1              /* Get state of receive error flag */
1219   1              return (((CAN_ERR_SR_REG.byte[2u] & CAN_RX_ERROR_FLAG_MASK) ==
1220   1                        CAN_RX_ERROR_FLAG_MASK) ? 1u : 0u);
1221   1          #else  /* CY_PSOC4 */
                      /* Get state of receive error flag */
                      return (((CAN_ERR_SR_REG & CAN_RX_ERROR_FLAG_MASK) ==
                                CAN_RX_ERROR_FLAG_MASK) ? 1u : 0u);
                  #endif /* CY_PSOC3 || CY_PSOC5 */
1226   1      
1227   1      }
1228          
1229          
1230          /*******************************************************************************
1231          * FUNCTION NAME:   CAN_GetTXErrorCount
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 21  

1232          ********************************************************************************
1233          *
1234          * Summary:
1235          *  This function returns the number of Transmit Errors.
1236          *
1237          * Parameters:
1238          *  None.
1239          *
1240          * Return:
1241          *  The number of Transmit Errors.
1242          *
1243          *******************************************************************************/
1244          uint8 CAN_GetTXErrorCount(void) 
1245          {
1246   1          #if (CY_PSOC3 || CY_PSOC5)
1247   1              /* Get state of transmit error count */
1248   1              return (CAN_ERR_SR_REG.byte[0u]);    /* bits 7-0 */
1249   1          #else  /* CY_PSOC4 */
                      /* Get state of transmit error count */
                      return ((uint8) CAN_ERR_SR_REG);    /* bits 7-0 */
                  #endif /* CY_PSOC3 || CY_PSOC5 */
1253   1      }
1254          
1255          
1256          /*******************************************************************************
1257          * FUNCTION NAME:   CAN_GetRXErrorCount
1258          ********************************************************************************
1259          *
1260          * Summary:
1261          *  This function returns the number of Receive Errors.
1262          *
1263          * Parameters:
1264          *  None.
1265          *
1266          * Return:
1267          *  The number of Receive Errors.
1268          *
1269          *******************************************************************************/
1270          uint8 CAN_GetRXErrorCount(void) 
1271          {
1272   1          #if (CY_PSOC3 || CY_PSOC5)
1273   1              /* Get state of receive error count */
1274   1              return (CAN_ERR_SR_REG.byte[1u]);    /* bits 15-8 */
1275   1          #else  /* CY_PSOC4 */
                      /* Get state of receive error count (bits 15-8) */
                      return ((uint8) (CAN_ERR_SR_REG >> CAN_ONE_BYTE_OFFSET));
                  #endif /* CY_PSOC3 || CY_PSOC5 */
1279   1      
1280   1      }
1281          
1282          
1283          /*******************************************************************************
1284          * FUNCTION NAME:   CAN_GetErrorState
1285          ********************************************************************************
1286          *
1287          * Summary:
1288          *  This function returns the error status of CAN Component.
1289          *
1290          * Parameters:
1291          *  None.
1292          *
1293          * Return:
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 22  

1294          *  The error status.
1295          *
1296          *******************************************************************************/
1297          uint8 CAN_GetErrorState(void) 
1298          {
1299   1          #if (CY_PSOC3 || CY_PSOC5)
1300   1              /* Get error state of receiver */
1301   1              return (CAN_ERR_SR_REG.byte[2u] & CAN_ERROR_STATE_MASK);
1302   1          #else  /* CY_PSOC4 */
                      /* Get error state of receiver */
                      return ((uint8) ((CAN_ERR_SR_REG >> CAN_TWO_BYTE_OFFSET) &
                              CAN_ERROR_STATE_MASK));
                  #endif /* CY_PSOC3 || CY_PSOC5 */
1307   1      }
1308          
1309          
1310          /*******************************************************************************
1311          * FUNCTION NAME:   CAN_RxBufConfig
1312          ********************************************************************************
1313          *
1314          * Summary:
1315          *  This function configures all receive registers for a particular mailbox.
1316          *
1317          * Parameters:
1318          *  rxConfig: The pointer to a structure that contain all required values to
1319          *  configure all receive registers for a particular mailbox.
1320          *
1321          * Return:
1322          *  The indication if particular configuration has been accepted or rejected.
1323          *   Define                             Description
1324          *    CYRET_SUCCESS                      The function passed successfully
1325          *    CAN_FAIL              The function failed
1326          *
1327          *******************************************************************************/
1328          uint8 CAN_RxBufConfig(const CAN_RX_CFG *rxConfig)
1329                                             
1330          {
1331   1          uint8 result = CAN_FAIL;
1332   1      
1333   1          /* Write RX CMD Register */
1334   1          CY_SET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxcmd), (rxConfig->rxcmd |
1335   1                       CAN_RX_WPN_SET));
1336   1          if ((CY_GET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxcmd)) &
1337   1               CAN_RX_READ_BACK_MASK) == (rxConfig->rxcmd & CAN_RX_WPN_CLEAR))
1338   1          {
1339   2              /* Write RX AMR Register */
1340   2              CY_SET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxamr), rxConfig->rxamr);
1341   2              if (CY_GET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxamr)) == rxConfig->rxamr)
1342   2              {
1343   3                  /* Write RX ACR Register */
1344   3                  CY_SET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxacr), rxConfig->rxacr);
1345   3                  if (CY_GET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxacr)) == rxConfig->rxacr)
1346   3                  {
1347   4                      /* Write RX AMRD Register */
1348   4                      CY_SET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxamrd), 0xFFFFFFFFu);
1349   4                      if (CY_GET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxamrd)) == 0xFFFFFFFFu)
1350   4                      {
1351   5                          /* Write RX ACRD Register */
1352   5                          CY_SET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxacrd), 0x00000000u);
1353   5                          if (CY_GET_REG32((reg32 *) (&CAN_RX[rxConfig->rxmailbox].rxacrd)) == 0x00000000u)
1354   5                          {
1355   6                              result = CYRET_SUCCESS;
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 23  

1356   6                          }
1357   5                      }
1358   4                  }
1359   3              }
1360   2          }
1361   1      
1362   1          return (result);
1363   1      }
1364          
1365          
1366          /*******************************************************************************
1367          * FUNCTION NAME:   CAN_TxBufConfig
1368          ********************************************************************************
1369          *
1370          * Summary:
1371          *  This function configures all transmit registers for a particular mailbox.
1372          *  Mailbox number contains CAN_TX_CFG structure.
1373          *
1374          * Parameters:
1375          *  txConfig: The pointer to structure that contain all required values to
1376          *  configure all transmit registers for a particular mailbox.
1377          *
1378          * Return:
1379          *  The indication if particular configuration has been accepted or rejected.
1380          *   Define                             Description
1381          *    CYRET_SUCCESS                      The function passed successfully
1382          *    CAN_FAIL              The function failed
1383          *
1384          *******************************************************************************/
1385          uint8 CAN_TxBufConfig(const CAN_TX_CFG *txConfig)
1386                                             
1387          {
1388   1          uint8 result = CAN_FAIL;
1389   1      
1390   1          /* Write TX CMD Register */
1391   1          CY_SET_REG32(CAN_TX_CMD_PTR(txConfig->txmailbox), (txConfig->txcmd | CAN_TX_WPN_SET));
1392   1          if ((CY_GET_REG32(CAN_TX_CMD_PTR(txConfig->txmailbox)) &
1393   1              CAN_TX_READ_BACK_MASK) == (txConfig->txcmd & CAN_TX_WPN_CLEAR))
1394   1          {
1395   2              /* Write TX ID Register */
1396   2              CY_SET_REG32(CAN_TX_ID_PTR(txConfig->txmailbox), txConfig->txid);
1397   2              if (CY_GET_REG32(CAN_TX_ID_PTR(txConfig->txmailbox)) == txConfig->txid)
1398   2              {
1399   3                  result = CYRET_SUCCESS;
1400   3              }
1401   2          }
1402   1      
1403   1          return (result);
1404   1      }
1405          
1406          
1407          #if (!(CY_PSOC3 || CY_PSOC5))
              
              /*******************************************************************************
              * FUNCTION NAME:   CAN_SetSwapDataEndianness
              ********************************************************************************
              *
              * Summary:
              *  This function selects whether the data byte endianness of the CAN receive and
              *  transmit data fields has to be swapped or not swapped. This is useful to
              *  match the data byte endianness to the endian setting of the processor or the
              *  used CAN protocol.
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 24  

              *
              * Parameters:
              *  swap: Swap Enable/Disable setting.
              *   Define                                   Description
              *   CAN_SWAP_ENDIANNESS_ENABLE   The endianness of transmitted/
              *                                             received data byte fields (Big
              *                                             endian) is not swapped during
              *                                             multibyte data transmission.
              *   CAN_SWAP_ENDIANNESS_DISABLE  The endianness of transmitted/
              *                                             received data byte fields is
              *                                             swapped (Little endian) during
              *                                             multi byte data transmission.
              *
              * Return:
              *  The indication whether the register is written and verified.
              *   Define                             Description
              *    CYRET_SUCCESS                      The function passed successfully
              *    CAN_FAIL              The function failed
              *
              *******************************************************************************/
              uint8 CAN_SetSwapDataEndianness(uint8 swap)
              {
                  uint8 result = CAN_FAIL;
              
                  if (swap == CAN_SWAP_ENDIANNESS_DISABLE)    /* Big endian */
                  {
                      CAN_CFG_REG &= (uint32) (~CAN_ENDIANNESS_MASK);
              
                      /* Verify that bit is cleared */
                      if ((CAN_CFG_REG & CAN_ENDIANNESS_MASK) == 0u)
                      {
                          result = CYRET_SUCCESS;
                      }
                  }
                  else    /* Little endian */
                  {
                      CAN_CFG_REG |= CAN_ENDIANNESS_MASK;
              
                      /* Verify that bit is set */
                      if ((CAN_CFG_REG & CAN_ENDIANNESS_MASK) != 0u)
                      {
                          result = CYRET_SUCCESS;
                      }
                  }
              
                  return (result);
              }
              
              
              /*******************************************************************************
              * FUNCTION NAME:   CAN_SetErrorCaptureRegisterMode
              ********************************************************************************
              *
              * Summary:
              *  This function sets the Error Capture register mode. The two modes are
              *  possible: Free Running and Error Capture.
              *
              * Parameters:
              *  ecrMode: The Error Capture register mode setting.
              *   Define                               Description
              *   CAN_ECR_FREE_RUNNING     The ECR captures the field and bit
              *                                         position within the current CAN frame.
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 25  

              *   CAN_ECR_ERROR_CAPTURE    In this mode the ECR register only
              *                                         captures an error event. For
              *                                         successive error captures, the ECR
              *                                         needs to be armed again by writing
              *                                         to the ECR register.
              *
              * Return:
              *  The indication whether the register is written and verified.
              *   Define                             Description
              *    CYRET_SUCCESS                      The function passed successfully
              *    CAN_FAIL              The function failed
              *
              *******************************************************************************/
              uint8 CAN_SetErrorCaptureRegisterMode(uint8 ecrMode)
              {
                  uint8 result = CAN_FAIL;
              
                  if (ecrMode == CAN_ECR_FREE_RUNNING)
                  {
                      CAN_CFG_REG &= (uint32) (~CAN_ECR_MODE_MASK);
              
                      /* Verify that bit is cleared */
                      if ((CAN_CFG_REG & CAN_ECR_MODE_MASK) == 0u)
                      {
                          result = CYRET_SUCCESS;
                      }
                  }
                  else    /* Capture mode */
                  {
                      CAN_CFG_REG |= CAN_ECR_MODE_MASK;
              
                      /* Verify that bit is set */
                      if ((CAN_CFG_REG & CAN_ECR_MODE_MASK) != 0u)
                      {
                          result = CYRET_SUCCESS;
                      }
                  }
              
                  return (result);
              }
              
              
              /*******************************************************************************
              * FUNCTION NAME:   CAN_ReadErrorCaptureRegister
              ********************************************************************************
              *
              * Summary:
              *  This function returns the value of the Error Capture register.
              *
              * Parameters:
              *  None.
              *
              * Return:
              *  The value of the Error Capture register.
              *   Bit  Name          Values
              *    0    ECR_STATUS    0: The ECR register captured an error or it is a free
              *                          running mode
              *                       1: The ECR register is armed
              *   3:1   ERROR_TYPE    000 : Arbitration loss
              *                       001 : Bit Error
              *                       010 : Bit Stuffing Error
              *                       011 : Acknowledge Error
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 26  

              *                       100 : Form Error
              *                       101 : CRC Error
              *                       Others : N/A
              *    4    TX_MODE       0: No status
              *                       1: CAN Controller is the transmitter
              *    5    RX_MODE       0: No status
              *                       1: CAN Controller is the receiver
              *  11:6   BIT           Bit number inside of Field
              *  12:16  Field         0x00 : Stopped
              *                       0x01 : Synchronize
              *                       0x05 : Interframe
              *                       0x06 : Bus Idle
              *                       0x07 : Start of Frame
              *                       0x08 : Arbitration
              *                       0x09 : Control
              *                       0x0A : Data
              *                       0x0B : CRC
              *                       0x0C : ACK
              *                       0x0D : End of frame
              *                       0x10 : Error flag
              *                       0x11 : Error echo
              *                       0x12 : Error delimiter
              *                       0x18 : Overload flag
              *                       0x19 : Overload echo
              *                       0x1A : Overload delimiter
              *                       Others : N/A
              *
              *******************************************************************************/
              uint32 CAN_ReadErrorCaptureRegister(void)
              {
                  return (CAN_ECR_REG);
              }
              
              
              /*******************************************************************************
              * FUNCTION NAME:   CAN_ArmErrorCaptureRegister
              ********************************************************************************
              *
              * Summary:
              *  This function arms the Error Capture register when the ECR is in the Error
              *  Capture mode, by setting the ECR_STATUS bit in the ECR register.
              *
              * Parameters:
              *  None.
              *
              * Return:
              *  The indication whether the register is written and verified.
              *   Define                             Description
              *    CYRET_SUCCESS                      The function passed successfully
              *    CAN_FAIL              The function failed
              *
              *******************************************************************************/
              uint8 CAN_ArmErrorCaptureRegister(void)
              {
                  uint8 result = CAN_FAIL;
              
                  CAN_ECR_REG |= CAN_ECR_STATUS_ARM;
              
                  /* Verify that bit is set */
                  if ((CAN_ECR_REG & CAN_ECR_STATUS_ARM) != 0u)
                  {
                      result = CYRET_SUCCESS;
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 27  

                  }
              
                  return (result);
              }
              
              #endif /* (!(CY_PSOC3 || CY_PSOC5)) */
1610          
1611          
1612          /* [] END OF FILE */
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 28  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION CAN_RxTxBuffersConfig (BEGIN)
                                           ; SOURCE LINE # 47
                                           ; SOURCE LINE # 48
                                           ; SOURCE LINE # 82
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 86
0005 900000      R     MOV     DPTR,#i
0008 E4                CLR     A
0009 F0                MOVX    @DPTR,A
000A         ?C0001:
000A 900000      R     MOV     DPTR,#i
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 C3                CLR     C
0011 9408              SUBB    A,#08H
0013 502E              JNC     ?C0002
                                           ; SOURCE LINE # 87
                                           ; SOURCE LINE # 89
0015 900000      R     MOV     DPTR,#i
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A 7E09              MOV     R6,#09H
001C EF                MOV     A,R7
001D 8EF0              MOV     B,R6
001F A4                MUL     AB
0020 FF                MOV     R7,A
0021 AEF0              MOV     R6,B
0023 7400        R     MOV     A,#LOW CAN_TXConfigStruct
0025 2F                ADD     A,R7
0026 F9                MOV     R1,A
0027 7400        R     MOV     A,#HIGH CAN_TXConfigStruct
0029 3E                ADDC    A,R6
002A FA                MOV     R2,A
002B 7BFF              MOV     R3,#0FFH
002D 120000      R     LCALL   _CAN_TxBufConfig
0030 EF                MOV     A,R7
0031 6008              JZ      ?C0003
                                           ; SOURCE LINE # 90
                                           ; SOURCE LINE # 91
0033 900000      R     MOV     DPTR,#result
0036 7401              MOV     A,#01H
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 92
0039 8008              SJMP    ?C0002
                                           ; SOURCE LINE # 93
                                           ; SOURCE LINE # 94
003B         ?C0003:
003B 900000      R     MOV     DPTR,#i
003E E0                MOVX    A,@DPTR
003F 04                INC     A
0040 F0                MOVX    @DPTR,A
0041 80C7              SJMP    ?C0001
0043         ?C0002:
                                           ; SOURCE LINE # 96
0043 900000      R     MOV     DPTR,#result
0046 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 29  

0047 FF                MOV     R7,A
0048 EF                MOV     A,R7
0049 703E              JNZ     ?C0005
                                           ; SOURCE LINE # 97
                                           ; SOURCE LINE # 99
004B 900000      R     MOV     DPTR,#i
004E E4                CLR     A
004F F0                MOVX    @DPTR,A
0050         ?C0006:
0050 900000      R     MOV     DPTR,#i
0053 E0                MOVX    A,@DPTR
0054 FF                MOV     R7,A
0055 EF                MOV     A,R7
0056 C3                CLR     C
0057 9410              SUBB    A,#010H
0059 502E              JNC     ?C0005
                                           ; SOURCE LINE # 100
                                           ; SOURCE LINE # 102
005B 900000      R     MOV     DPTR,#i
005E E0                MOVX    A,@DPTR
005F FF                MOV     R7,A
0060 7E0D              MOV     R6,#0DH
0062 EF                MOV     A,R7
0063 8EF0              MOV     B,R6
0065 A4                MUL     AB
0066 FF                MOV     R7,A
0067 AEF0              MOV     R6,B
0069 7400        R     MOV     A,#LOW CAN_RXConfigStruct
006B 2F                ADD     A,R7
006C F9                MOV     R1,A
006D 7400        R     MOV     A,#HIGH CAN_RXConfigStruct
006F 3E                ADDC    A,R6
0070 FA                MOV     R2,A
0071 7BFF              MOV     R3,#0FFH
0073 120000      R     LCALL   _CAN_RxBufConfig
0076 EF                MOV     A,R7
0077 6008              JZ      ?C0008
                                           ; SOURCE LINE # 103
                                           ; SOURCE LINE # 104
0079 900000      R     MOV     DPTR,#result
007C 7401              MOV     A,#01H
007E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 105
007F 8008              SJMP    ?C0005
                                           ; SOURCE LINE # 106
                                           ; SOURCE LINE # 107
0081         ?C0008:
0081 900000      R     MOV     DPTR,#i
0084 E0                MOVX    A,@DPTR
0085 04                INC     A
0086 F0                MOVX    @DPTR,A
0087 80C7              SJMP    ?C0006
                                           ; SOURCE LINE # 108
0089         ?C0005:
                                           ; SOURCE LINE # 110
0089 900000      R     MOV     DPTR,#result
008C E0                MOVX    A,@DPTR
008D FF                MOV     R7,A
                                           ; SOURCE LINE # 111
008E         ?C0010:
008E 22                RET     
             ; FUNCTION CAN_RxTxBuffersConfig (END)
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 30  


             ; FUNCTION CAN_Init (BEGIN)
                                           ; SOURCE LINE # 137
                                           ; SOURCE LINE # 138
                                           ; SOURCE LINE # 139
0000 7F00              MOV     R7,#00H
0002 7E78              MOV     R6,#078H
0004 7D00              MOV     R5,#00H
0006 7C00              MOV     R4,#00H
0008 900000      R     MOV     DPTR,#timeout
000B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 140
000E 900000      R     MOV     DPTR,#result
0011 7401              MOV     A,#01H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 141
0014 900000      R     MOV     DPTR,#localResult
0017 7401              MOV     A,#01H
0019 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 146
001A 120000      E     LCALL   CyEnterCriticalSection
001D 900000      R     MOV     DPTR,#enableInterrupts
0020 EF                MOV     A,R7
0021 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 148
0022 9043A6            MOV     DPTR,#043A6H
0025 E0                MOVX    A,@DPTR
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
0028 4401              ORL     A,#01H
002A FF                MOV     R7,A
002B EF                MOV     A,R7
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 150
002D 9043B6            MOV     DPTR,#043B6H
0030 E0                MOVX    A,@DPTR
0031 FF                MOV     R7,A
0032 EF                MOV     A,R7
0033 4401              ORL     A,#01H
0035 FF                MOV     R7,A
0036 EF                MOV     A,R7
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 151
0038 900000      R     MOV     DPTR,#enableInterrupts
003B E0                MOVX    A,@DPTR
003C FF                MOV     R7,A
003D 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 154
0040 90A010            MOV     DPTR,#0A010H
0043 E0                MOVX    A,@DPTR
0044 FF                MOV     R7,A
0045 EF                MOV     A,R7
0046 54FE              ANL     A,#0FEH
0048 FF                MOV     R7,A
0049 EF                MOV     A,R7
004A F0                MOVX    @DPTR,A
004B         ?C0011:
                                           ; SOURCE LINE # 157
004B 900000      R     MOV     DPTR,#timeout
004E 120000      E     LCALL   ?C?LLDXDATA
0051 EF                MOV     A,R7
0052 4E                ORL     A,R6
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 31  

0053 6022              JZ      ?C0012
0055 90A010            MOV     DPTR,#0A010H
0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A EF                MOV     A,R7
005B 30E019            JNB     ACC.0,?C0012
                                           ; SOURCE LINE # 158
                                           ; SOURCE LINE # 159
005E 900000      R     MOV     DPTR,#timeout
0061 120000      E     LCALL   ?C?LLDXDATA
0064 7BFF              MOV     R3,#0FFH
0066 7AFF              MOV     R2,#0FFH
0068 79FF              MOV     R1,#0FFH
006A 78FF              MOV     R0,#0FFH
006C 120000      E     LCALL   ?C?LADD
006F 900000      R     MOV     DPTR,#timeout
0072 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 160
0075 80D4              SJMP    ?C0011
0077         ?C0012:
                                           ; SOURCE LINE # 174
0077 900000      R     MOV     DPTR,#timeout
007A 120000      E     LCALL   ?C?LLDXDATA
007D EF                MOV     A,R7
007E 4E                ORL     A,R6
007F 6079              JZ      ?C0013
                                           ; SOURCE LINE # 175
                                           ; SOURCE LINE # 177
0081 9044CA            MOV     DPTR,#044CAH
0084 7401              MOV     A,#01H
0086 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 180
0087 7C00        E     MOV     R4,#HIGH CAN_ISR
0089 7D00        E     MOV     R5,#LOW CAN_ISR
008B 7F10              MOV     R7,#010H
008D 120000      E     LCALL   _CyIntSetVector
                                           ; SOURCE LINE # 183
0090 7D07              MOV     R5,#07H
0092 7F10              MOV     R7,#010H
0094 120000      E     LCALL   _CyIntSetPriority
                                           ; SOURCE LINE # 185
0097 7F0B              MOV     R7,#0BH
0099 7E00              MOV     R6,#00H
009B 120000      R     LCALL   _CAN_SetPreScaler
009E EF                MOV     A,R7
009F 702E              JNZ     ?C0014
                                           ; SOURCE LINE # 186
                                           ; SOURCE LINE # 187
00A1 7F00              MOV     R7,#00H
00A3 120000      R     LCALL   _CAN_SetArbiter
00A6 EF                MOV     A,R7
00A7 7026              JNZ     ?C0014
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 192
                                           ; SOURCE LINE # 193
00A9 900000      R     MOV     DPTR,#?_CAN_SetTsegSample?BYTE+03H
00AC E4                CLR     A
00AD F0                MOVX    @DPTR,A
00AE 7B03              MOV     R3,#03H
00B0 7D04              MOV     R5,#04H
00B2 7F09              MOV     R7,#09H
00B4 120000      R     LCALL   _CAN_SetTsegSample
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 32  

00B7 EF                MOV     A,R7
00B8 7015              JNZ     ?C0014
                                           ; SOURCE LINE # 196
                                           ; SOURCE LINE # 197
00BA 7F00              MOV     R7,#00H
00BC 120000      R     LCALL   _CAN_SetRestartType
00BF EF                MOV     A,R7
00C0 700D              JNZ     ?C0014
                                           ; SOURCE LINE # 198
                                           ; SOURCE LINE # 199
00C2 7F00              MOV     R7,#00H
00C4 120000      R     LCALL   _CAN_SetEdgeMode
00C7 EF                MOV     A,R7
00C8 7005              JNZ     ?C0014
                                           ; SOURCE LINE # 200
                                           ; SOURCE LINE # 201
00CA 900000      R     MOV     DPTR,#localResult
00CD E4                CLR     A
00CE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 202
                                           ; SOURCE LINE # 203
                                           ; SOURCE LINE # 204
                                           ; SOURCE LINE # 205
                                           ; SOURCE LINE # 206
                                           ; SOURCE LINE # 207
00CF         ?C0014:
                                           ; SOURCE LINE # 209
00CF 900000      R     MOV     DPTR,#localResult
00D2 E0                MOVX    A,@DPTR
00D3 FF                MOV     R7,A
00D4 EF                MOV     A,R7
00D5 7023              JNZ     ?C0013
                                           ; SOURCE LINE # 210
                                           ; SOURCE LINE # 211
00D7 120000      R     LCALL   CAN_RxTxBuffersConfig
00DA EF                MOV     A,R7
00DB 701D              JNZ     ?C0013
                                           ; SOURCE LINE # 212
                                           ; SOURCE LINE # 214
00DD 7F01              MOV     R7,#01H
00DF 7E10              MOV     R6,#010H
00E1 120000      R     LCALL   _CAN_SetIrqMask
00E4 EF                MOV     A,R7
00E5 7013              JNZ     ?C0013
                                           ; SOURCE LINE # 216
                                           ; SOURCE LINE # 219
00E7 90A010            MOV     DPTR,#0A010H
00EA E4                CLR     A
00EB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 220
00EC 90A010            MOV     DPTR,#0A010H
00EF E0                MOVX    A,@DPTR
00F0 FF                MOV     R7,A
00F1 EF                MOV     A,R7
00F2 20E005            JB      ACC.0,?C0013
                                           ; SOURCE LINE # 225
                                           ; SOURCE LINE # 226
00F5 900000      R     MOV     DPTR,#result
00F8 E4                CLR     A
00F9 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 33  

                                           ; SOURCE LINE # 229
                                           ; SOURCE LINE # 230
                                           ; SOURCE LINE # 231
00FA         ?C0013:
                                           ; SOURCE LINE # 233
00FA 900000      R     MOV     DPTR,#result
00FD E0                MOVX    A,@DPTR
00FE FF                MOV     R7,A
                                           ; SOURCE LINE # 234
00FF         ?C0023:
00FF 22                RET     
             ; FUNCTION CAN_Init (END)

             ; FUNCTION CAN_Enable (BEGIN)
                                           ; SOURCE LINE # 254
                                           ; SOURCE LINE # 255
                                           ; SOURCE LINE # 256
0000 7F00              MOV     R7,#00H
0002 7E09              MOV     R6,#09H
0004 7D00              MOV     R5,#00H
0006 7C00              MOV     R4,#00H
0008 900000      R     MOV     DPTR,#timeout
000B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 257
000E 900000      R     MOV     DPTR,#result
0011 7401              MOV     A,#01H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 262
0014 120000      E     LCALL   CyEnterCriticalSection
0017 900000      R     MOV     DPTR,#enableInterrupts
001A EF                MOV     A,R7
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 265
001C 9043A6            MOV     DPTR,#043A6H
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 4401              ORL     A,#01H
0024 FF                MOV     R7,A
0025 EF                MOV     A,R7
0026 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 268
0027 9043B6            MOV     DPTR,#043B6H
002A E0                MOVX    A,@DPTR
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D 4401              ORL     A,#01H
002F FF                MOV     R7,A
0030 EF                MOV     A,R7
0031 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 270
0032 900000      R     MOV     DPTR,#enableInterrupts
0035 E0                MOVX    A,@DPTR
0036 FF                MOV     R7,A
0037 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 274
003A 7B02              MOV     R3,#02H
003C 7AA0              MOV     R2,#0A0H
003E 7900              MOV     R1,#00H
0040 7F01              MOV     R7,#01H
0042 7E10              MOV     R6,#010H
0044 7D00              MOV     R5,#00H
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 34  

0046 7C00              MOV     R4,#00H
0048 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 275
004B 120000      R     LCALL   CAN_GlobalIntEnable
                                           ; SOURCE LINE # 278
004E 9044C2            MOV     DPTR,#044C2H
0051 7401              MOV     A,#01H
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 281
0054 7B02              MOV     R3,#02H
0056 7AA0              MOV     R2,#0A0H
0058 7910              MOV     R1,#010H
005A 120000      E     LCALL   _cyread32_nodpx
005D EF                MOV     A,R7
005E 4401              ORL     A,#01H
0060 FF                MOV     R7,A
0061 EE                MOV     A,R6
0062 4400              ORL     A,#00H
0064 FE                MOV     R6,A
0065 ED                MOV     A,R5
0066 4400              ORL     A,#00H
0068 FD                MOV     R5,A
0069 EC                MOV     A,R4
006A 4400              ORL     A,#00H
006C FC                MOV     R4,A
006D 7B02              MOV     R3,#02H
006F 7AA0              MOV     R2,#0A0H
0071 7910              MOV     R1,#010H
0073 120000      E     LCALL   _cywrite32_nodpx
0076         ?C0024:
                                           ; SOURCE LINE # 284
0076 900000      R     MOV     DPTR,#timeout
0079 120000      E     LCALL   ?C?LLDXDATA
007C EF                MOV     A,R7
007D 4E                ORL     A,R6
007E 6036              JZ      ?C0025
0080 7B02              MOV     R3,#02H
0082 7AA0              MOV     R2,#0A0H
0084 7910              MOV     R1,#010H
0086 120000      E     LCALL   _cyread32_nodpx
0089 EF                MOV     A,R7
008A 5401              ANL     A,#01H
008C FF                MOV     R7,A
008D EE                MOV     A,R6
008E 5400              ANL     A,#00H
0090 FE                MOV     R6,A
0091 ED                MOV     A,R5
0092 5400              ANL     A,#00H
0094 FD                MOV     R5,A
0095 EC                MOV     A,R4
0096 5400              ANL     A,#00H
0098 FC                MOV     R4,A
0099 EF                MOV     A,R7
009A 4E                ORL     A,R6
009B 7019              JNZ     ?C0025
                                           ; SOURCE LINE # 285
                                           ; SOURCE LINE # 286
009D 900000      R     MOV     DPTR,#timeout
00A0 120000      E     LCALL   ?C?LLDXDATA
00A3 7BFF              MOV     R3,#0FFH
00A5 7AFF              MOV     R2,#0FFH
00A7 79FF              MOV     R1,#0FFH
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 35  

00A9 78FF              MOV     R0,#0FFH
00AB 120000      E     LCALL   ?C?LADD
00AE 900000      R     MOV     DPTR,#timeout
00B1 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 287
00B4 80C0              SJMP    ?C0024
00B6         ?C0025:
                                           ; SOURCE LINE # 289
00B6 900000      R     MOV     DPTR,#timeout
00B9 120000      E     LCALL   ?C?LLDXDATA
00BC EF                MOV     A,R7
00BD 4E                ORL     A,R6
00BE 6005              JZ      ?C0026
                                           ; SOURCE LINE # 290
                                           ; SOURCE LINE # 291
00C0 900000      R     MOV     DPTR,#result
00C3 E4                CLR     A
00C4 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 292
00C5         ?C0026:
                                           ; SOURCE LINE # 294
00C5 900000      R     MOV     DPTR,#result
00C8 E0                MOVX    A,@DPTR
00C9 FF                MOV     R7,A
                                           ; SOURCE LINE # 295
00CA         ?C0027:
00CA 22                RET     
             ; FUNCTION CAN_Enable (END)

             ; FUNCTION CAN_Start (BEGIN)
                                           ; SOURCE LINE # 323
                                           ; SOURCE LINE # 324
                                           ; SOURCE LINE # 325
0000 900000      R     MOV     DPTR,#result
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 327
0005 900000      R     MOV     DPTR,#CAN_initVar
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 7008              JNZ     ?C0028
                                           ; SOURCE LINE # 328
                                           ; SOURCE LINE # 329
000D 120000      R     LCALL   CAN_Init
0010 900000      R     MOV     DPTR,#result
0013 EF                MOV     A,R7
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 330
0015         ?C0028:
                                           ; SOURCE LINE # 332
0015 900000      R     MOV     DPTR,#result
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A EF                MOV     A,R7
001B 700E              JNZ     ?C0029
                                           ; SOURCE LINE # 333
                                           ; SOURCE LINE # 334
001D 900000      R     MOV     DPTR,#CAN_initVar
0020 7401              MOV     A,#01H
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 335
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 36  

0023 120000      R     LCALL   CAN_Enable
0026 900000      R     MOV     DPTR,#result
0029 EF                MOV     A,R7
002A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 336
002B         ?C0029:
                                           ; SOURCE LINE # 338
002B 900000      R     MOV     DPTR,#result
002E E0                MOVX    A,@DPTR
002F FF                MOV     R7,A
                                           ; SOURCE LINE # 339
0030         ?C0030:
0030 22                RET     
             ; FUNCTION CAN_Start (END)

             ; FUNCTION CAN_Stop (BEGIN)
                                           ; SOURCE LINE # 366
                                           ; SOURCE LINE # 367
                                           ; SOURCE LINE # 368
0000 7F00              MOV     R7,#00H
0002 7E78              MOV     R6,#078H
0004 7D00              MOV     R5,#00H
0006 7C00              MOV     R4,#00H
0008 900000      R     MOV     DPTR,#timeout
000B 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 369
000E 900000      R     MOV     DPTR,#result
0011 7401              MOV     A,#01H
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 377
0014 7B02              MOV     R3,#02H
0016 7AA0              MOV     R2,#0A0H
0018 7910              MOV     R1,#010H
001A 120000      E     LCALL   _cyread32_nodpx
001D EF                MOV     A,R7
001E 54FE              ANL     A,#0FEH
0020 FF                MOV     R7,A
0021 EE                MOV     A,R6
0022 54FF              ANL     A,#0FFH
0024 FE                MOV     R6,A
0025 ED                MOV     A,R5
0026 54FF              ANL     A,#0FFH
0028 FD                MOV     R5,A
0029 EC                MOV     A,R4
002A 54FF              ANL     A,#0FFH
002C FC                MOV     R4,A
002D 7B02              MOV     R3,#02H
002F 7AA0              MOV     R2,#0A0H
0031 7910              MOV     R1,#010H
0033 120000      E     LCALL   _cywrite32_nodpx
0036         ?C0031:
                                           ; SOURCE LINE # 380
0036 900000      R     MOV     DPTR,#timeout
0039 120000      E     LCALL   ?C?LLDXDATA
003C EF                MOV     A,R7
003D 4E                ORL     A,R6
003E 6036              JZ      ?C0032
0040 7B02              MOV     R3,#02H
0042 7AA0              MOV     R2,#0A0H
0044 7910              MOV     R1,#010H
0046 120000      E     LCALL   _cyread32_nodpx
0049 EF                MOV     A,R7
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 37  

004A 5401              ANL     A,#01H
004C FF                MOV     R7,A
004D EE                MOV     A,R6
004E 5400              ANL     A,#00H
0050 FE                MOV     R6,A
0051 ED                MOV     A,R5
0052 5400              ANL     A,#00H
0054 FD                MOV     R5,A
0055 EC                MOV     A,R4
0056 5400              ANL     A,#00H
0058 FC                MOV     R4,A
0059 EF                MOV     A,R7
005A 4E                ORL     A,R6
005B 6019              JZ      ?C0032
                                           ; SOURCE LINE # 381
                                           ; SOURCE LINE # 382
005D 900000      R     MOV     DPTR,#timeout
0060 120000      E     LCALL   ?C?LLDXDATA
0063 7BFF              MOV     R3,#0FFH
0065 7AFF              MOV     R2,#0FFH
0067 79FF              MOV     R1,#0FFH
0069 78FF              MOV     R0,#0FFH
006B 120000      E     LCALL   ?C?LADD
006E 900000      R     MOV     DPTR,#timeout
0071 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 383
0074 80C0              SJMP    ?C0031
0076         ?C0032:
                                           ; SOURCE LINE # 386
0076 900000      R     MOV     DPTR,#timeout
0079 120000      E     LCALL   ?C?LLDXDATA
007C EF                MOV     A,R7
007D 4E                ORL     A,R6
007E 6031              JZ      ?C0033
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 388
0080 900000      R     MOV     DPTR,#result
0083 E4                CLR     A
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 391
0085 9044CA            MOV     DPTR,#044CAH
0088 7401              MOV     A,#01H
008A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 394
008B 120000      E     LCALL   CyEnterCriticalSection
008E 900000      R     MOV     DPTR,#enableInterrupts
0091 EF                MOV     A,R7
0092 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 397
0093 9043A6            MOV     DPTR,#043A6H
0096 E0                MOVX    A,@DPTR
0097 FF                MOV     R7,A
0098 EF                MOV     A,R7
0099 54FE              ANL     A,#0FEH
009B FF                MOV     R7,A
009C EF                MOV     A,R7
009D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 400
009E 9043B6            MOV     DPTR,#043B6H
00A1 E0                MOVX    A,@DPTR
00A2 FF                MOV     R7,A
00A3 EF                MOV     A,R7
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 38  

00A4 54FE              ANL     A,#0FEH
00A6 FF                MOV     R7,A
00A7 EF                MOV     A,R7
00A8 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 402
00A9 900000      R     MOV     DPTR,#enableInterrupts
00AC E0                MOVX    A,@DPTR
00AD FF                MOV     R7,A
00AE 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 404
00B1         ?C0033:
                                           ; SOURCE LINE # 406
00B1 900000      R     MOV     DPTR,#result
00B4 E0                MOVX    A,@DPTR
00B5 FF                MOV     R7,A
                                           ; SOURCE LINE # 407
00B6         ?C0034:
00B6 22                RET     
             ; FUNCTION CAN_Stop (END)

             ; FUNCTION CAN_GlobalIntEnable (BEGIN)
                                           ; SOURCE LINE # 427
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
0000 900000      R     MOV     DPTR,#result
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 432
0006 90A004            MOV     DPTR,#0A004H
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C 4401              ORL     A,#01H
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 435
0011 90A004            MOV     DPTR,#0A004H
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 30E005            JNB     ACC.0,?C0035
                                           ; SOURCE LINE # 436
                                           ; SOURCE LINE # 437
001A 900000      R     MOV     DPTR,#result
001D E4                CLR     A
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 438
001F         ?C0035:
                                           ; SOURCE LINE # 448
001F 900000      R     MOV     DPTR,#result
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
                                           ; SOURCE LINE # 449
0024         ?C0036:
0024 22                RET     
             ; FUNCTION CAN_GlobalIntEnable (END)

             ; FUNCTION CAN_GlobalIntDisable (BEGIN)
                                           ; SOURCE LINE # 469
                                           ; SOURCE LINE # 470
                                           ; SOURCE LINE # 471
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 39  

0000 900000      R     MOV     DPTR,#result
0003 7401              MOV     A,#01H
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 474
0006 90A004            MOV     DPTR,#0A004H
0009 E0                MOVX    A,@DPTR
000A FF                MOV     R7,A
000B EF                MOV     A,R7
000C 54FE              ANL     A,#0FEH
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 477
0011 90A004            MOV     DPTR,#0A004H
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 EF                MOV     A,R7
0017 20E005            JB      ACC.0,?C0037
                                           ; SOURCE LINE # 478
                                           ; SOURCE LINE # 479
001A 900000      R     MOV     DPTR,#result
001D E4                CLR     A
001E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 480
001F         ?C0037:
                                           ; SOURCE LINE # 491
001F 900000      R     MOV     DPTR,#result
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
                                           ; SOURCE LINE # 492
0024         ?C0038:
0024 22                RET     
             ; FUNCTION CAN_GlobalIntDisable (END)

             ; FUNCTION _CAN_SetPreScaler (BEGIN)
                                           ; SOURCE LINE # 519
0000 900000      R     MOV     DPTR,#bitrate
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 520
                                           ; SOURCE LINE # 521
0008 900000      R     MOV     DPTR,#result
000B 7402              MOV     A,#02H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 523
000E 900000      R     MOV     DPTR,#bitrate
0011 E0                MOVX    A,@DPTR
0012 FE                MOV     R6,A
0013 A3                INC     DPTR
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 D3                SETB    C
0017 EF                MOV     A,R7
0018 94FF              SUBB    A,#0FFH
001A EE                MOV     A,R6
001B 947F              SUBB    A,#07FH
001D 5035              JNC     ?C0039
                                           ; SOURCE LINE # 524
                                           ; SOURCE LINE # 525
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 40  

001F 900000      R     MOV     DPTR,#result
0022 7401              MOV     A,#01H
0024 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 529
0025 7B02              MOV     R3,#02H
0027 7AA0              MOV     R2,#0A0H
0029 7916              MOV     R1,#016H
002B 900000      R     MOV     DPTR,#bitrate
002E E0                MOVX    A,@DPTR
002F FC                MOV     R4,A
0030 A3                INC     DPTR
0031 E0                MOVX    A,@DPTR
0032 FD                MOV     R5,A
0033 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 532
0036 7B02              MOV     R3,#02H
0038 7AA0              MOV     R2,#0A0H
003A 7916              MOV     R1,#016H
003C 120000      E     LCALL   _cyread16_nodpx
003F 900000      R     MOV     DPTR,#bitrate
0042 E0                MOVX    A,@DPTR
0043 FC                MOV     R4,A
0044 A3                INC     DPTR
0045 E0                MOVX    A,@DPTR
0046 FD                MOV     R5,A
0047 EF                MOV     A,R7
0048 B50509            CJNE    A,AR5,?C0039
004B EE                MOV     A,R6
004C B50405            CJNE    A,AR4,?C0039
                                           ; SOURCE LINE # 533
                                           ; SOURCE LINE # 534
004F 900000      R     MOV     DPTR,#result
0052 E4                CLR     A
0053 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 535
                                           ; SOURCE LINE # 548
0054         ?C0039:
                                           ; SOURCE LINE # 550
0054 900000      R     MOV     DPTR,#result
0057 E0                MOVX    A,@DPTR
0058 FF                MOV     R7,A
                                           ; SOURCE LINE # 551
0059         ?C0041:
0059 22                RET     
             ; FUNCTION _CAN_SetPreScaler (END)

             ; FUNCTION _CAN_SetArbiter (BEGIN)
                                           ; SOURCE LINE # 575
0000 900000      R     MOV     DPTR,#arbiter
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 576
                                           ; SOURCE LINE # 577
0005 900000      R     MOV     DPTR,#result
0008 7401              MOV     A,#01H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 580
000B 900000      R     MOV     DPTR,#arbiter
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 701B              JNZ     ?C0042
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 41  

                                           ; SOURCE LINE # 581
                                           ; SOURCE LINE # 582
0013 90A015            MOV     DPTR,#0A015H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54EF              ANL     A,#0EFH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 585
001E 90A015            MOV     DPTR,#0A015H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 20E420            JB      ACC.4,?C0044
                                           ; SOURCE LINE # 586
                                           ; SOURCE LINE # 587
0027 900000      R     MOV     DPTR,#result
002A E4                CLR     A
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 588
                                           ; SOURCE LINE # 589
002C 8019              SJMP    ?C0044
002E         ?C0042:
                                           ; SOURCE LINE # 591
                                           ; SOURCE LINE # 592
002E 90A015            MOV     DPTR,#0A015H
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 4410              ORL     A,#010H
0036 FF                MOV     R7,A
0037 EF                MOV     A,R7
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 595
0039 90A015            MOV     DPTR,#0A015H
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F 30E405            JNB     ACC.4,?C0044
                                           ; SOURCE LINE # 596
                                           ; SOURCE LINE # 597
0042 900000      R     MOV     DPTR,#result
0045 E4                CLR     A
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 598
                                           ; SOURCE LINE # 599
0047         ?C0044:
                                           ; SOURCE LINE # 623
0047 900000      R     MOV     DPTR,#result
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
                                           ; SOURCE LINE # 624
004C         ?C0046:
004C 22                RET     
             ; FUNCTION _CAN_SetArbiter (END)

             ; FUNCTION _CAN_SetTsegSample (BEGIN)
                                           ; SOURCE LINE # 652
0000 900000      R     MOV     DPTR,#cfgTseg1
0003 EF                MOV     A,R7
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 42  

0004 F0                MOVX    @DPTR,A
0005 900000      R     MOV     DPTR,#cfgTseg2
0008 ED                MOV     A,R5
0009 F0                MOVX    @DPTR,A
000A 900000      R     MOV     DPTR,#sjw
000D EB                MOV     A,R3
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 654
                                           ; SOURCE LINE # 655
000F 900000      R     MOV     DPTR,#result
0012 7402              MOV     A,#02H
0014 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 658
0015 900000      R     MOV     DPTR,#cfgTseg1
0018 E0                MOVX    A,@DPTR
0019 FF                MOV     R7,A
001A EF                MOV     A,R7
001B C3                CLR     C
001C 9402              SUBB    A,#02H
001E 5003              JNC     $ + 5H
0020 020000      R     LJMP    ?C0047
0023 900000      R     MOV     DPTR,#cfgTseg1
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 EF                MOV     A,R7
0029 D3                SETB    C
002A 940F              SUBB    A,#0FH
002C 4003              JC      $ + 5H
002E 020000      R     LJMP    ?C0047
                                           ; SOURCE LINE # 660
                                           ; SOURCE LINE # 661
0031 900000      R     MOV     DPTR,#cfgTseg2
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
0036 EF                MOV     A,R7
0037 C3                CLR     C
0038 9402              SUBB    A,#02H
003A 400B              JC      ?C0050
003C 900000      R     MOV     DPTR,#cfgTseg2
003F E0                MOVX    A,@DPTR
0040 FF                MOV     R7,A
0041 EF                MOV     A,R7
0042 D3                SETB    C
0043 9407              SUBB    A,#07H
0045 4018              JC      ?C0049
0047         ?C0050:
0047 900000      R     MOV     DPTR,#sm
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
004C EF                MOV     A,R7
004D 6003              JZ      $ + 5H
004F 020000      R     LJMP    ?C0047
0052 900000      R     MOV     DPTR,#cfgTseg2
0055 E0                MOVX    A,@DPTR
0056 FF                MOV     R7,A
0057 EF                MOV     A,R7
0058 6401              XRL     A,#01H
005A 6003              JZ      $ + 5H
005C 020000      R     LJMP    ?C0047
005F         ?C0049:
                                           ; SOURCE LINE # 664
                                           ; SOURCE LINE # 665
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 43  

005F 900000      R     MOV     DPTR,#sjw
0062 E0                MOVX    A,@DPTR
0063 FF                MOV     R7,A
0064 EF                MOV     A,R7
0065 D3                SETB    C
0066 9403              SUBB    A,#03H
0068 4003              JC      $ + 5H
006A 020000      R     LJMP    ?C0047
006D 900000      R     MOV     DPTR,#cfgTseg1
0070 E0                MOVX    A,@DPTR
0071 FF                MOV     R7,A
0072 900000      R     MOV     DPTR,#sjw
0075 E0                MOVX    A,@DPTR
0076 FE                MOV     R6,A
0077 EE                MOV     A,R6
0078 D3                SETB    C
0079 9F                SUBB    A,R7
007A 4003              JC      $ + 5H
007C 020000      R     LJMP    ?C0047
007F 900000      R     MOV     DPTR,#cfgTseg2
0082 E0                MOVX    A,@DPTR
0083 FF                MOV     R7,A
0084 900000      R     MOV     DPTR,#sjw
0087 E0                MOVX    A,@DPTR
0088 FE                MOV     R6,A
0089 EE                MOV     A,R6
008A D3                SETB    C
008B 9F                SUBB    A,R7
008C 4003              JC      $ + 5H
008E 020000      R     LJMP    ?C0047
                                           ; SOURCE LINE # 666
                                           ; SOURCE LINE # 667
0091 900000      R     MOV     DPTR,#result
0094 7401              MOV     A,#01H
0096 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 670
0097 90A015            MOV     DPTR,#0A015H
009A E0                MOVX    A,@DPTR
009B FF                MOV     R7,A
009C 900000      R     MOV     DPTR,#cfgTemp
009F EF                MOV     A,R7
00A0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 671
00A1 900000      R     MOV     DPTR,#cfgTemp
00A4 E0                MOVX    A,@DPTR
00A5 FF                MOV     R7,A
00A6 EF                MOV     A,R7
00A7 54F0              ANL     A,#0F0H
00A9 FF                MOV     R7,A
00AA 900000      R     MOV     DPTR,#cfgTemp
00AD EF                MOV     A,R7
00AE F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 672
00AF 900000      R     MOV     DPTR,#cfgTemp
00B2 E0                MOVX    A,@DPTR
00B3 FF                MOV     R7,A
00B4 900000      R     MOV     DPTR,#cfgTseg1
00B7 E0                MOVX    A,@DPTR
00B8 FE                MOV     R6,A
00B9 EF                MOV     A,R7
00BA 4E                ORL     A,R6
00BB FF                MOV     R7,A
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 44  

00BC 900000      R     MOV     DPTR,#cfgTemp
00BF EF                MOV     A,R7
00C0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 675
00C1 900000      R     MOV     DPTR,#cfgTemp
00C4 E0                MOVX    A,@DPTR
00C5 FF                MOV     R7,A
00C6 90A015            MOV     DPTR,#0A015H
00C9 EF                MOV     A,R7
00CA F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 678
00CB 900000      R     MOV     DPTR,#cfgTemp
00CE E0                MOVX    A,@DPTR
00CF FF                MOV     R7,A
00D0 90A015            MOV     DPTR,#0A015H
00D3 E0                MOVX    A,@DPTR
00D4 FE                MOV     R6,A
00D5 EE                MOV     A,R6
00D6 6F                XRL     A,R7
00D7 7056              JNZ     ?C0047
                                           ; SOURCE LINE # 679
                                           ; SOURCE LINE # 680
00D9 900000      R     MOV     DPTR,#cfgTemp
00DC E4                CLR     A
00DD F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 682
00DE 900000      R     MOV     DPTR,#sm
00E1 E0                MOVX    A,@DPTR
00E2 FF                MOV     R7,A
00E3 EF                MOV     A,R7
00E4 6006              JZ      ?C0053
                                           ; SOURCE LINE # 683
                                           ; SOURCE LINE # 684
00E6 900000      R     MOV     DPTR,#cfgTemp
00E9 7402              MOV     A,#02H
00EB F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 685
00EC         ?C0053:
                                           ; SOURCE LINE # 687
00EC 900000      R     MOV     DPTR,#cfgTemp
00EF E0                MOVX    A,@DPTR
00F0 FF                MOV     R7,A
00F1 900000      R     MOV     DPTR,#sjw
00F4 E0                MOVX    A,@DPTR
00F5 FE                MOV     R6,A
00F6 EE                MOV     A,R6
00F7 25E0              ADD     A,ACC
00F9 25E0              ADD     A,ACC
00FB FE                MOV     R6,A
00FC 900000      R     MOV     DPTR,#cfgTseg2
00FF E0                MOVX    A,@DPTR
0100 FD                MOV     R5,A
0101 ED                MOV     A,R5
0102 C4                SWAP    A
0103 33                RLC     A
0104 54E0              ANL     A,#0E0H
0106 FD                MOV     R5,A
0107 ED                MOV     A,R5
0108 4E                ORL     A,R6
0109 FE                MOV     R6,A
010A EF                MOV     A,R7
010B 4E                ORL     A,R6
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 45  

010C FF                MOV     R7,A
010D 900000      R     MOV     DPTR,#cfgTemp
0110 EF                MOV     A,R7
0111 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 690
0112 900000      R     MOV     DPTR,#cfgTemp
0115 E0                MOVX    A,@DPTR
0116 FF                MOV     R7,A
0117 90A014            MOV     DPTR,#0A014H
011A EF                MOV     A,R7
011B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 693
011C 900000      R     MOV     DPTR,#cfgTemp
011F E0                MOVX    A,@DPTR
0120 FF                MOV     R7,A
0121 90A014            MOV     DPTR,#0A014H
0124 E0                MOVX    A,@DPTR
0125 FE                MOV     R6,A
0126 EE                MOV     A,R6
0127 B50705            CJNE    A,AR7,?C0047
                                           ; SOURCE LINE # 694
                                           ; SOURCE LINE # 695
012A 900000      R     MOV     DPTR,#result
012D E4                CLR     A
012E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 696
                                           ; SOURCE LINE # 697
                                           ; SOURCE LINE # 736
                                           ; SOURCE LINE # 737
                                           ; SOURCE LINE # 738
012F         ?C0047:
                                           ; SOURCE LINE # 740
012F 900000      R     MOV     DPTR,#result
0132 E0                MOVX    A,@DPTR
0133 FF                MOV     R7,A
                                           ; SOURCE LINE # 741
0134         ?C0055:
0134 22                RET     
             ; FUNCTION _CAN_SetTsegSample (END)

             ; FUNCTION _CAN_SetRestartType (BEGIN)
                                           ; SOURCE LINE # 769
0000 900000      R     MOV     DPTR,#reset
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 770
                                           ; SOURCE LINE # 771
0005 900000      R     MOV     DPTR,#result
0008 7401              MOV     A,#01H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 774
000B 900000      R     MOV     DPTR,#reset
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 701B              JNZ     ?C0056
                                           ; SOURCE LINE # 775
                                           ; SOURCE LINE # 776
0013 90A014            MOV     DPTR,#0A014H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 46  

0019 54EF              ANL     A,#0EFH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 779
001E 90A014            MOV     DPTR,#0A014H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 20E420            JB      ACC.4,?C0058
                                           ; SOURCE LINE # 780
                                           ; SOURCE LINE # 781
0027 900000      R     MOV     DPTR,#result
002A E4                CLR     A
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 782
                                           ; SOURCE LINE # 783
002C 8019              SJMP    ?C0058
002E         ?C0056:
                                           ; SOURCE LINE # 785
                                           ; SOURCE LINE # 786
002E 90A014            MOV     DPTR,#0A014H
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 4410              ORL     A,#010H
0036 FF                MOV     R7,A
0037 EF                MOV     A,R7
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 789
0039 90A014            MOV     DPTR,#0A014H
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F 30E405            JNB     ACC.4,?C0058
                                           ; SOURCE LINE # 790
                                           ; SOURCE LINE # 791
0042 900000      R     MOV     DPTR,#result
0045 E4                CLR     A
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 792
                                           ; SOURCE LINE # 793
0047         ?C0058:
                                           ; SOURCE LINE # 817
0047 900000      R     MOV     DPTR,#result
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
                                           ; SOURCE LINE # 818
004C         ?C0060:
004C 22                RET     
             ; FUNCTION _CAN_SetRestartType (END)

             ; FUNCTION _CAN_SetEdgeMode (BEGIN)
                                           ; SOURCE LINE # 843
0000 900000      R     MOV     DPTR,#edge
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 844
                                           ; SOURCE LINE # 845
0005 900000      R     MOV     DPTR,#result
0008 7401              MOV     A,#01H
000A F0                MOVX    @DPTR,A
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 47  

                                           ; SOURCE LINE # 848
000B 900000      R     MOV     DPTR,#edge
000E E0                MOVX    A,@DPTR
000F FF                MOV     R7,A
0010 EF                MOV     A,R7
0011 701B              JNZ     ?C0061
                                           ; SOURCE LINE # 849
                                           ; SOURCE LINE # 851
0013 90A014            MOV     DPTR,#0A014H
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 854
001E 90A014            MOV     DPTR,#0A014H
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 20E020            JB      ACC.0,?C0063
                                           ; SOURCE LINE # 855
                                           ; SOURCE LINE # 856
0027 900000      R     MOV     DPTR,#result
002A E4                CLR     A
002B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 857
                                           ; SOURCE LINE # 858
002C 8019              SJMP    ?C0063
002E         ?C0061:
                                           ; SOURCE LINE # 860
                                           ; SOURCE LINE # 862
002E 90A014            MOV     DPTR,#0A014H
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 EF                MOV     A,R7
0034 4401              ORL     A,#01H
0036 FF                MOV     R7,A
0037 EF                MOV     A,R7
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 865
0039 90A014            MOV     DPTR,#0A014H
003C E0                MOVX    A,@DPTR
003D FF                MOV     R7,A
003E EF                MOV     A,R7
003F 30E005            JNB     ACC.0,?C0063
                                           ; SOURCE LINE # 866
                                           ; SOURCE LINE # 867
0042 900000      R     MOV     DPTR,#result
0045 E4                CLR     A
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 868
                                           ; SOURCE LINE # 869
0047         ?C0063:
                                           ; SOURCE LINE # 895
0047 900000      R     MOV     DPTR,#result
004A E0                MOVX    A,@DPTR
004B FF                MOV     R7,A
                                           ; SOURCE LINE # 896
004C         ?C0065:
004C 22                RET     
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 48  

             ; FUNCTION _CAN_SetEdgeMode (END)

             ; FUNCTION _CAN_SetOpMode (BEGIN)
                                           ; SOURCE LINE # 938
0000 900000      R     MOV     DPTR,#opMode
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 939
                                           ; SOURCE LINE # 943
0005 900000      R     MOV     DPTR,#result
0008 7401              MOV     A,#01H
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 944
000B 900000      R     MOV     DPTR,#runState
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 947
0010 90A010            MOV     DPTR,#0A010H
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 5401              ANL     A,#01H
0018 FF                MOV     R7,A
0019 7E00              MOV     R6,#00H
001B EF                MOV     A,R7
001C 4E                ORL     A,R6
001D 7009              JNZ     ?C0067
001F 900000      R     MOV     DPTR,#opMode
0022 E0                MOVX    A,@DPTR
0023 FF                MOV     R7,A
0024 EF                MOV     A,R7
0025 B40106            CJNE    A,#01H,?C0066
0028         ?C0067:
                                           ; SOURCE LINE # 949
                                           ; SOURCE LINE # 950
0028 900000      R     MOV     DPTR,#runState
002B 7401              MOV     A,#01H
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 951
002E         ?C0066:
                                           ; SOURCE LINE # 954
002E 90A010            MOV     DPTR,#0A010H
0031 E4                CLR     A
0032 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 959
0033 7F00              MOV     R7,#00H
0035 7E78              MOV     R6,#078H
0037 7D00              MOV     R5,#00H
0039 7C00              MOV     R4,#00H
003B 900000      R     MOV     DPTR,#timeout
003E 120000      E     LCALL   ?C?LSTXDATA
0041         ?C0068:
0041 900000      R     MOV     DPTR,#timeout
0044 120000      E     LCALL   ?C?LLDXDATA
0047 EF                MOV     A,R7
0048 4E                ORL     A,R6
0049 6028              JZ      ?C0069
004B 90A010            MOV     DPTR,#0A010H
004E E0                MOVX    A,@DPTR
004F FF                MOV     R7,A
0050 EF                MOV     A,R7
0051 5401              ANL     A,#01H
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 49  

0053 FF                MOV     R7,A
0054 7E00              MOV     R6,#00H
0056 EF                MOV     A,R7
0057 4E                ORL     A,R6
0058 6019              JZ      ?C0069
                                           ; SOURCE LINE # 960
                                           ; SOURCE LINE # 961
                                           ; SOURCE LINE # 959
005A 900000      R     MOV     DPTR,#timeout
005D 120000      E     LCALL   ?C?LLDXDATA
0060 7BFF              MOV     R3,#0FFH
0062 7AFF              MOV     R2,#0FFH
0064 79FF              MOV     R1,#0FFH
0066 78FF              MOV     R0,#0FFH
0068 120000      E     LCALL   ?C?LADD
006B 900000      R     MOV     DPTR,#timeout
006E 120000      E     LCALL   ?C?LSTXDATA
0071 80CE              SJMP    ?C0068
0073         ?C0069:
                                           ; SOURCE LINE # 963
0073 900000      R     MOV     DPTR,#timeout
0076 120000      E     LCALL   ?C?LLDXDATA
0079 EF                MOV     A,R7
007A 4E                ORL     A,R6
007B 6005              JZ      ?C0071
                                           ; SOURCE LINE # 964
                                           ; SOURCE LINE # 965
007D 900000      R     MOV     DPTR,#result
0080 E4                CLR     A
0081 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 966
0082         ?C0071:
                                           ; SOURCE LINE # 968
0082 900000      R     MOV     DPTR,#result
0085 E0                MOVX    A,@DPTR
0086 FF                MOV     R7,A
0087 EF                MOV     A,R7
0088 7076              JNZ     ?C0072
008A 900000      R     MOV     DPTR,#opMode
008D E0                MOVX    A,@DPTR
008E FF                MOV     R7,A
008F EF                MOV     A,R7
0090 606E              JZ      ?C0072
                                           ; SOURCE LINE # 969
                                           ; SOURCE LINE # 970
0092 900000      R     MOV     DPTR,#opMode
0095 E0                MOVX    A,@DPTR
0096 FF                MOV     R7,A
0097 EF                MOV     A,R7
0098 B40206            CJNE    A,#02H,?C0073
                                           ; SOURCE LINE # 971
                                           ; SOURCE LINE # 972
009B 90A010            MOV     DPTR,#0A010H
009E 7402              MOV     A,#02H
00A0 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 973
00A1         ?C0073:
                                           ; SOURCE LINE # 975
00A1 900000      R     MOV     DPTR,#runState
00A4 E0                MOVX    A,@DPTR
00A5 FF                MOV     R7,A
00A6 EF                MOV     A,R7
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 50  

00A7 6401              XRL     A,#01H
00A9 7055              JNZ     ?C0072
                                           ; SOURCE LINE # 976
                                           ; SOURCE LINE # 977
00AB 90A010            MOV     DPTR,#0A010H
00AE E0                MOVX    A,@DPTR
00AF FF                MOV     R7,A
00B0 EF                MOV     A,R7
00B1 4401              ORL     A,#01H
00B3 FF                MOV     R7,A
00B4 EF                MOV     A,R7
00B5 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 982
00B6 7F00              MOV     R7,#00H
00B8 7E09              MOV     R6,#09H
00BA 7D00              MOV     R5,#00H
00BC 7C00              MOV     R4,#00H
00BE 900000      R     MOV     DPTR,#timeout
00C1 120000      E     LCALL   ?C?LSTXDATA
00C4         ?C0075:
00C4 900000      R     MOV     DPTR,#timeout
00C7 120000      E     LCALL   ?C?LLDXDATA
00CA EF                MOV     A,R7
00CB 4E                ORL     A,R6
00CC 6022              JZ      ?C0076
00CE 90A010            MOV     DPTR,#0A010H
00D1 E0                MOVX    A,@DPTR
00D2 FF                MOV     R7,A
00D3 EF                MOV     A,R7
00D4 20E019            JB      ACC.0,?C0076
                                           ; SOURCE LINE # 983
                                           ; SOURCE LINE # 984
                                           ; SOURCE LINE # 982
00D7 900000      R     MOV     DPTR,#timeout
00DA 120000      E     LCALL   ?C?LLDXDATA
00DD 7BFF              MOV     R3,#0FFH
00DF 7AFF              MOV     R2,#0FFH
00E1 79FF              MOV     R1,#0FFH
00E3 78FF              MOV     R0,#0FFH
00E5 120000      E     LCALL   ?C?LADD
00E8 900000      R     MOV     DPTR,#timeout
00EB 120000      E     LCALL   ?C?LSTXDATA
00EE 80D4              SJMP    ?C0075
00F0         ?C0076:
                                           ; SOURCE LINE # 986
00F0 900000      R     MOV     DPTR,#timeout
00F3 120000      E     LCALL   ?C?LLDXDATA
00F6 EF                MOV     A,R7
00F7 4E                ORL     A,R6
00F8 7006              JNZ     ?C0072
                                           ; SOURCE LINE # 987
                                           ; SOURCE LINE # 988
00FA 900000      R     MOV     DPTR,#result
00FD 7401              MOV     A,#01H
00FF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 989
                                           ; SOURCE LINE # 990
                                           ; SOURCE LINE # 991
0100         ?C0072:
                                           ; SOURCE LINE # 1027
0100 900000      R     MOV     DPTR,#result
0103 E0                MOVX    A,@DPTR
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 51  

0104 FF                MOV     R7,A
                                           ; SOURCE LINE # 1028
0105         ?C0079:
0105 22                RET     
             ; FUNCTION _CAN_SetOpMode (END)

             ; FUNCTION _CAN_RXRegisterInit (BEGIN)
                                           ; SOURCE LINE # 1050
0000 900000      R     MOV     DPTR,#regAddr
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1052
                                           ; SOURCE LINE # 1053
0008 900000      R     MOV     DPTR,#result
000B 7402              MOV     A,#02H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1058
000E 900000      R     MOV     DPTR,#regAddr
0011 E0                MOVX    A,@DPTR
0012 FE                MOV     R6,A
0013 A3                INC     DPTR
0014 E0                MOVX    A,@DPTR
0015 FF                MOV     R7,A
0016 E4                CLR     A
0017 FC                MOV     R4,A
0018 FD                MOV     R5,A
0019 EF                MOV     A,R7
001A 54FF              ANL     A,#0FFH
001C FF                MOV     R7,A
001D EE                MOV     A,R6
001E 54FF              ANL     A,#0FFH
0020 FE                MOV     R6,A
0021 ED                MOV     A,R5
0022 5400              ANL     A,#00H
0024 FD                MOV     R5,A
0025 EC                MOV     A,R4
0026 5400              ANL     A,#00H
0028 FC                MOV     R4,A
0029 7BA0              MOV     R3,#0A0H
002B 7AA0              MOV     R2,#0A0H
002D 7900              MOV     R1,#00H
002F 7800              MOV     R0,#00H
0031 D3                SETB    C
0032 120000      E     LCALL   ?C?ULCMP
0035 4003              JC      $ + 5H
0037 020000      R     LJMP    ?C0080
003A 900000      R     MOV     DPTR,#regAddr
003D E0                MOVX    A,@DPTR
003E FE                MOV     R6,A
003F A3                INC     DPTR
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
0042 E4                CLR     A
0043 FC                MOV     R4,A
0044 FD                MOV     R5,A
0045 EF                MOV     A,R7
0046 54FF              ANL     A,#0FFH
0048 FF                MOV     R7,A
0049 EE                MOV     A,R6
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 52  

004A 54FF              ANL     A,#0FFH
004C FE                MOV     R6,A
004D ED                MOV     A,R5
004E 5400              ANL     A,#00H
0050 FD                MOV     R5,A
0051 EC                MOV     A,R4
0052 5400              ANL     A,#00H
0054 FC                MOV     R4,A
0055 7B9C              MOV     R3,#09CH
0057 7AA2              MOV     R2,#0A2H
0059 7900              MOV     R1,#00H
005B 7800              MOV     R0,#00H
005D C3                CLR     C
005E 120000      E     LCALL   ?C?ULCMP
0061 5003              JNC     $ + 5H
0063 020000      R     LJMP    ?C0080
                                           ; SOURCE LINE # 1059
                                           ; SOURCE LINE # 1060
0066 900000      R     MOV     DPTR,#result
0069 7401              MOV     A,#01H
006B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1062
006C 900000      R     MOV     DPTR,#regAddr
006F E0                MOVX    A,@DPTR
0070 FE                MOV     R6,A
0071 A3                INC     DPTR
0072 E0                MOVX    A,@DPTR
0073 FF                MOV     R7,A
0074 E4                CLR     A
0075 FC                MOV     R4,A
0076 FD                MOV     R5,A
0077 EF                MOV     A,R7
0078 541F              ANL     A,#01FH
007A FF                MOV     R7,A
007B EE                MOV     A,R6
007C 5400              ANL     A,#00H
007E FE                MOV     R6,A
007F ED                MOV     A,R5
0080 5400              ANL     A,#00H
0082 FD                MOV     R5,A
0083 EC                MOV     A,R4
0084 5400              ANL     A,#00H
0086 FC                MOV     R4,A
0087 EF                MOV     A,R7
0088 4E                ORL     A,R6
0089 6003              JZ      $ + 5H
008B 020000      R     LJMP    ?C0081
                                           ; SOURCE LINE # 1063
                                           ; SOURCE LINE # 1064
008E 900000      R     MOV     DPTR,#config
0091 120000      E     LCALL   ?C?LLDXDATA
0094 EF                MOV     A,R7
0095 4480              ORL     A,#080H
0097 FF                MOV     R7,A
0098 EE                MOV     A,R6
0099 4400              ORL     A,#00H
009B FE                MOV     R6,A
009C ED                MOV     A,R5
009D 4480              ORL     A,#080H
009F FD                MOV     R5,A
00A0 EC                MOV     A,R4
00A1 4400              ORL     A,#00H
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 53  

00A3 FC                MOV     R4,A
00A4 900000      R     MOV     DPTR,#config
00A7 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 1067
00AA 9044CA            MOV     DPTR,#044CAH
00AD 7401              MOV     A,#01H
00AF F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1070
00B0 900000      R     MOV     DPTR,#regAddr
00B3 E0                MOVX    A,@DPTR
00B4 FE                MOV     R6,A
00B5 A3                INC     DPTR
00B6 E0                MOVX    A,@DPTR
00B7 FF                MOV     R7,A
00B8 AA06              MOV     R2,AR6
00BA A907              MOV     R1,AR7
00BC 7B01              MOV     R3,#01H
00BE 900000      R     MOV     DPTR,#config
00C1 120000      E     LCALL   ?C?LLDXDATA
00C4 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1073
00C7 9044C2            MOV     DPTR,#044C2H
00CA 7401              MOV     A,#01H
00CC F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1077
00CD 900000      R     MOV     DPTR,#regAddr
00D0 E0                MOVX    A,@DPTR
00D1 FE                MOV     R6,A
00D2 A3                INC     DPTR
00D3 E0                MOVX    A,@DPTR
00D4 FF                MOV     R7,A
00D5 AA06              MOV     R2,AR6
00D7 A907              MOV     R1,AR7
00D9 7B01              MOV     R3,#01H
00DB 120000      E     LCALL   _cyread32_nodpx
00DE EF                MOV     A,R7
00DF 547F              ANL     A,#07FH
00E1 FB                MOV     R3,A
00E2 EE                MOV     A,R6
00E3 5400              ANL     A,#00H
00E5 FA                MOV     R2,A
00E6 ED                MOV     A,R5
00E7 547F              ANL     A,#07FH
00E9 F9                MOV     R1,A
00EA EC                MOV     A,R4
00EB 5400              ANL     A,#00H
00ED F8                MOV     R0,A
00EE 900000      R     MOV     DPTR,#config
00F1 120000      E     LCALL   ?C?LLDXDATA
00F4 EF                MOV     A,R7
00F5 547F              ANL     A,#07FH
00F7 FF                MOV     R7,A
00F8 EE                MOV     A,R6
00F9 5400              ANL     A,#00H
00FB FE                MOV     R6,A
00FC ED                MOV     A,R5
00FD 547F              ANL     A,#07FH
00FF FD                MOV     R5,A
0100 EC                MOV     A,R4
0101 5400              ANL     A,#00H
0103 FC                MOV     R4,A
0104 C3                CLR     C
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 54  

0105 120000      E     LCALL   ?C?ULCMP
0108 704C              JNZ     ?C0080
                                           ; SOURCE LINE # 1078
                                           ; SOURCE LINE # 1079
010A 900000      R     MOV     DPTR,#result
010D E4                CLR     A
010E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1080
                                           ; SOURCE LINE # 1081
010F 8045              SJMP    ?C0080
0111         ?C0081:
                                           ; SOURCE LINE # 1084
                                           ; SOURCE LINE # 1086
0111 9044CA            MOV     DPTR,#044CAH
0114 7401              MOV     A,#01H
0116 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1089
0117 900000      R     MOV     DPTR,#regAddr
011A E0                MOVX    A,@DPTR
011B FE                MOV     R6,A
011C A3                INC     DPTR
011D E0                MOVX    A,@DPTR
011E FF                MOV     R7,A
011F AA06              MOV     R2,AR6
0121 A907              MOV     R1,AR7
0123 7B01              MOV     R3,#01H
0125 900000      R     MOV     DPTR,#config
0128 120000      E     LCALL   ?C?LLDXDATA
012B 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1092
012E 9044C2            MOV     DPTR,#044C2H
0131 7401              MOV     A,#01H
0133 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1095
0134 900000      R     MOV     DPTR,#regAddr
0137 E0                MOVX    A,@DPTR
0138 FE                MOV     R6,A
0139 A3                INC     DPTR
013A E0                MOVX    A,@DPTR
013B FF                MOV     R7,A
013C AA06              MOV     R2,AR6
013E A907              MOV     R1,AR7
0140 7B01              MOV     R3,#01H
0142 120000      E     LCALL   _cyread32_nodpx
0145 900000      R     MOV     DPTR,#config
0148 120000      E     LCALL   ?C?LLDXDATA0
014B C3                CLR     C
014C 120000      E     LCALL   ?C?ULCMP
014F 7005              JNZ     ?C0080
                                           ; SOURCE LINE # 1096
                                           ; SOURCE LINE # 1097
0151 900000      R     MOV     DPTR,#result
0154 E4                CLR     A
0155 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1098
                                           ; SOURCE LINE # 1099
                                           ; SOURCE LINE # 1100
0156         ?C0080:
                                           ; SOURCE LINE # 1102
0156 900000      R     MOV     DPTR,#result
0159 E0                MOVX    A,@DPTR
015A FF                MOV     R7,A
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 55  

                                           ; SOURCE LINE # 1103
015B         ?C0085:
015B 22                RET     
             ; FUNCTION _CAN_RXRegisterInit (END)

             ; FUNCTION _CAN_SetIrqMask (BEGIN)
                                           ; SOURCE LINE # 1142
0000 900000      R     MOV     DPTR,#mask
0003 EE                MOV     A,R6
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1143
                                           ; SOURCE LINE # 1144
0008 900000      R     MOV     DPTR,#result
000B 7401              MOV     A,#01H
000D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1148
000E 7B02              MOV     R3,#02H
0010 7AA0              MOV     R2,#0A0H
0012 7904              MOV     R1,#04H
0014 900000      R     MOV     DPTR,#mask
0017 E0                MOVX    A,@DPTR
0018 FC                MOV     R4,A
0019 A3                INC     DPTR
001A E0                MOVX    A,@DPTR
001B FD                MOV     R5,A
001C 120000      E     LCALL   _cywrite16_nodpx
                                           ; SOURCE LINE # 1151
001F 7B02              MOV     R3,#02H
0021 7AA0              MOV     R2,#0A0H
0023 7904              MOV     R1,#04H
0025 120000      E     LCALL   _cyread16_nodpx
0028 900000      R     MOV     DPTR,#mask
002B E0                MOVX    A,@DPTR
002C FC                MOV     R4,A
002D A3                INC     DPTR
002E E0                MOVX    A,@DPTR
002F FD                MOV     R5,A
0030 EF                MOV     A,R7
0031 B50509            CJNE    A,AR5,?C0086
0034 EE                MOV     A,R6
0035 B50405            CJNE    A,AR4,?C0086
                                           ; SOURCE LINE # 1152
                                           ; SOURCE LINE # 1153
0038 900000      R     MOV     DPTR,#result
003B E4                CLR     A
003C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1154
003D         ?C0086:
                                           ; SOURCE LINE # 1166
003D 900000      R     MOV     DPTR,#result
0040 E0                MOVX    A,@DPTR
0041 FF                MOV     R7,A
                                           ; SOURCE LINE # 1167
0042         ?C0087:
0042 22                RET     
             ; FUNCTION _CAN_SetIrqMask (END)

             ; FUNCTION CAN_GetTXErrorFlag (BEGIN)
                                           ; SOURCE LINE # 1185
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 56  

                                           ; SOURCE LINE # 1186
                                           ; SOURCE LINE # 1190
0000 90A00E            MOV     DPTR,#0A00EH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E204            JNB     ACC.2,?C0088
0009 7F01              MOV     R7,#01H
000B 8002              SJMP    ?C0089
000D         ?C0088:
000D 7F00              MOV     R7,#00H
000F         ?C0089:
                                           ; SOURCE LINE # 1197
000F         ?C0090:
000F 22                RET     
             ; FUNCTION CAN_GetTXErrorFlag (END)

             ; FUNCTION CAN_GetRXErrorFlag (BEGIN)
                                           ; SOURCE LINE # 1215
                                           ; SOURCE LINE # 1216
                                           ; SOURCE LINE # 1220
0000 90A00E            MOV     DPTR,#0A00EH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E304            JNB     ACC.3,?C0091
0009 7F01              MOV     R7,#01H
000B 8002              SJMP    ?C0092
000D         ?C0091:
000D 7F00              MOV     R7,#00H
000F         ?C0092:
                                           ; SOURCE LINE # 1227
000F         ?C0093:
000F 22                RET     
             ; FUNCTION CAN_GetRXErrorFlag (END)

             ; FUNCTION CAN_GetTXErrorCount (BEGIN)
                                           ; SOURCE LINE # 1244
                                           ; SOURCE LINE # 1245
                                           ; SOURCE LINE # 1248
0000 90A00C            MOV     DPTR,#0A00CH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1253
0005         ?C0094:
0005 22                RET     
             ; FUNCTION CAN_GetTXErrorCount (END)

             ; FUNCTION CAN_GetRXErrorCount (BEGIN)
                                           ; SOURCE LINE # 1270
                                           ; SOURCE LINE # 1271
                                           ; SOURCE LINE # 1274
0000 90A00D            MOV     DPTR,#0A00DH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
                                           ; SOURCE LINE # 1280
0005         ?C0095:
0005 22                RET     
             ; FUNCTION CAN_GetRXErrorCount (END)

             ; FUNCTION CAN_GetErrorState (BEGIN)
                                           ; SOURCE LINE # 1297
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 57  

                                           ; SOURCE LINE # 1298
                                           ; SOURCE LINE # 1301
0000 90A00E            MOV     DPTR,#0A00EH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 5403              ANL     A,#03H
0008 FF                MOV     R7,A
                                           ; SOURCE LINE # 1307
0009         ?C0096:
0009 22                RET     
             ; FUNCTION CAN_GetErrorState (END)

             ; FUNCTION _CAN_RxBufConfig (BEGIN)
                                           ; SOURCE LINE # 1328
0000 900000      R     MOV     DPTR,#rxConfig
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1330
                                           ; SOURCE LINE # 1331
0006 900000      R     MOV     DPTR,#result
0009 7401              MOV     A,#01H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1335
000C 900000      R     MOV     DPTR,#rxConfig
000F 120000      E     LCALL   ?C?PLDXDATA
0012 120000      E     LCALL   ?C?CLDPTR
0015 FF                MOV     R7,A
0016 7E20              MOV     R6,#020H
0018 EF                MOV     A,R7
0019 8EF0              MOV     B,R6
001B A4                MUL     AB
001C FF                MOV     R7,A
001D AEF0              MOV     R6,B
001F EF                MOV     A,R7
0020 24A0              ADD     A,#0A0H
0022 FF                MOV     R7,A
0023 EE                MOV     A,R6
0024 34A0              ADDC    A,#0A0H
0026 FE                MOV     R6,A
0027 AA06              MOV     R2,AR6
0029 A907              MOV     R1,AR7
002B 7B01              MOV     R3,#01H
002D C003              PUSH    AR3
002F C002              PUSH    AR2
0031 C001              PUSH    AR1
0033 900000      R     MOV     DPTR,#rxConfig
0036 120000      E     LCALL   ?C?PLDXDATA
0039 E9                MOV     A,R1
003A 2401              ADD     A,#01H
003C F9                MOV     R1,A
003D EA                MOV     A,R2
003E 3400              ADDC    A,#00H
0040 FA                MOV     R2,A
0041 120000      E     LCALL   ?C?LLDPTR
0044 EF                MOV     A,R7
0045 4480              ORL     A,#080H
0047 FF                MOV     R7,A
0048 EE                MOV     A,R6
0049 4400              ORL     A,#00H
004B FE                MOV     R6,A
004C ED                MOV     A,R5
004D 4480              ORL     A,#080H
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 58  

004F FD                MOV     R5,A
0050 EC                MOV     A,R4
0051 4400              ORL     A,#00H
0053 FC                MOV     R4,A
0054 D001              POP     AR1
0056 D002              POP     AR2
0058 D003              POP     AR3
005A 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1337
005D 900000      R     MOV     DPTR,#rxConfig
0060 120000      E     LCALL   ?C?PLDXDATA
0063 120000      E     LCALL   ?C?CLDPTR
0066 FF                MOV     R7,A
0067 7E20              MOV     R6,#020H
0069 EF                MOV     A,R7
006A 8EF0              MOV     B,R6
006C A4                MUL     AB
006D FF                MOV     R7,A
006E AEF0              MOV     R6,B
0070 EF                MOV     A,R7
0071 24A0              ADD     A,#0A0H
0073 FF                MOV     R7,A
0074 EE                MOV     A,R6
0075 34A0              ADDC    A,#0A0H
0077 FE                MOV     R6,A
0078 AA06              MOV     R2,AR6
007A A907              MOV     R1,AR7
007C 7B01              MOV     R3,#01H
007E 120000      E     LCALL   _cyread32_nodpx
0081 EF                MOV     A,R7
0082 547F              ANL     A,#07FH
0084 FF                MOV     R7,A
0085 EE                MOV     A,R6
0086 5400              ANL     A,#00H
0088 FE                MOV     R6,A
0089 ED                MOV     A,R5
008A 547F              ANL     A,#07FH
008C FD                MOV     R5,A
008D EC                MOV     A,R4
008E 5400              ANL     A,#00H
0090 FC                MOV     R4,A
0091 C004              PUSH    AR4
0093 C005              PUSH    AR5
0095 C006              PUSH    AR6
0097 C007              PUSH    AR7
0099 900000      R     MOV     DPTR,#rxConfig
009C 120000      E     LCALL   ?C?PLDXDATA
009F E9                MOV     A,R1
00A0 2401              ADD     A,#01H
00A2 F9                MOV     R1,A
00A3 EA                MOV     A,R2
00A4 3400              ADDC    A,#00H
00A6 FA                MOV     R2,A
00A7 120000      E     LCALL   ?C?LLDPTR
00AA EF                MOV     A,R7
00AB 547F              ANL     A,#07FH
00AD FB                MOV     R3,A
00AE EE                MOV     A,R6
00AF 54FF              ANL     A,#0FFH
00B1 FA                MOV     R2,A
00B2 ED                MOV     A,R5
00B3 547F              ANL     A,#07FH
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 59  

00B5 F9                MOV     R1,A
00B6 EC                MOV     A,R4
00B7 54FF              ANL     A,#0FFH
00B9 F8                MOV     R0,A
00BA D007              POP     AR7
00BC D006              POP     AR6
00BE D005              POP     AR5
00C0 D004              POP     AR4
00C2 C3                CLR     C
00C3 120000      E     LCALL   ?C?ULCMP
00C6 6003              JZ      $ + 5H
00C8 020000      R     LJMP    ?C0097
                                           ; SOURCE LINE # 1338
                                           ; SOURCE LINE # 1340
00CB 900000      R     MOV     DPTR,#rxConfig
00CE 120000      E     LCALL   ?C?PLDXDATA
00D1 120000      E     LCALL   ?C?CLDPTR
00D4 FF                MOV     R7,A
00D5 7E20              MOV     R6,#020H
00D7 EF                MOV     A,R7
00D8 8EF0              MOV     B,R6
00DA A4                MUL     AB
00DB FF                MOV     R7,A
00DC AEF0              MOV     R6,B
00DE EF                MOV     A,R7
00DF 24B0              ADD     A,#0B0H
00E1 FF                MOV     R7,A
00E2 EE                MOV     A,R6
00E3 34A0              ADDC    A,#0A0H
00E5 FE                MOV     R6,A
00E6 AA06              MOV     R2,AR6
00E8 A907              MOV     R1,AR7
00EA 7B01              MOV     R3,#01H
00EC C003              PUSH    AR3
00EE C002              PUSH    AR2
00F0 C001              PUSH    AR1
00F2 900000      R     MOV     DPTR,#rxConfig
00F5 120000      E     LCALL   ?C?PLDXDATA
00F8 E9                MOV     A,R1
00F9 2405              ADD     A,#05H
00FB F9                MOV     R1,A
00FC EA                MOV     A,R2
00FD 3400              ADDC    A,#00H
00FF FA                MOV     R2,A
0100 120000      E     LCALL   ?C?LLDPTR
0103 D001              POP     AR1
0105 D002              POP     AR2
0107 D003              POP     AR3
0109 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1341
010C 900000      R     MOV     DPTR,#rxConfig
010F 120000      E     LCALL   ?C?PLDXDATA
0112 120000      E     LCALL   ?C?CLDPTR
0115 FF                MOV     R7,A
0116 7E20              MOV     R6,#020H
0118 EF                MOV     A,R7
0119 8EF0              MOV     B,R6
011B A4                MUL     AB
011C FF                MOV     R7,A
011D AEF0              MOV     R6,B
011F EF                MOV     A,R7
0120 24B0              ADD     A,#0B0H
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 60  

0122 FF                MOV     R7,A
0123 EE                MOV     A,R6
0124 34A0              ADDC    A,#0A0H
0126 FE                MOV     R6,A
0127 AA06              MOV     R2,AR6
0129 A907              MOV     R1,AR7
012B 7B01              MOV     R3,#01H
012D 120000      E     LCALL   _cyread32_nodpx
0130 900000      R     MOV     DPTR,#rxConfig
0133 120000      E     LCALL   ?C?PLDXDATA
0136 E9                MOV     A,R1
0137 2405              ADD     A,#05H
0139 F9                MOV     R1,A
013A EA                MOV     A,R2
013B 3400              ADDC    A,#00H
013D FA                MOV     R2,A
013E 120000      E     LCALL   ?C?LLDPTR0
0141 C3                CLR     C
0142 120000      E     LCALL   ?C?ULCMP
0145 6003              JZ      $ + 5H
0147 020000      R     LJMP    ?C0097
                                           ; SOURCE LINE # 1342
                                           ; SOURCE LINE # 1344
014A 900000      R     MOV     DPTR,#rxConfig
014D 120000      E     LCALL   ?C?PLDXDATA
0150 120000      E     LCALL   ?C?CLDPTR
0153 FF                MOV     R7,A
0154 7E20              MOV     R6,#020H
0156 EF                MOV     A,R7
0157 8EF0              MOV     B,R6
0159 A4                MUL     AB
015A FF                MOV     R7,A
015B AEF0              MOV     R6,B
015D EF                MOV     A,R7
015E 24B4              ADD     A,#0B4H
0160 FF                MOV     R7,A
0161 EE                MOV     A,R6
0162 34A0              ADDC    A,#0A0H
0164 FE                MOV     R6,A
0165 AA06              MOV     R2,AR6
0167 A907              MOV     R1,AR7
0169 7B01              MOV     R3,#01H
016B C003              PUSH    AR3
016D C002              PUSH    AR2
016F C001              PUSH    AR1
0171 900000      R     MOV     DPTR,#rxConfig
0174 120000      E     LCALL   ?C?PLDXDATA
0177 E9                MOV     A,R1
0178 2409              ADD     A,#09H
017A F9                MOV     R1,A
017B EA                MOV     A,R2
017C 3400              ADDC    A,#00H
017E FA                MOV     R2,A
017F 120000      E     LCALL   ?C?LLDPTR
0182 D001              POP     AR1
0184 D002              POP     AR2
0186 D003              POP     AR3
0188 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1345
018B 900000      R     MOV     DPTR,#rxConfig
018E 120000      E     LCALL   ?C?PLDXDATA
0191 120000      E     LCALL   ?C?CLDPTR
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 61  

0194 FF                MOV     R7,A
0195 7E20              MOV     R6,#020H
0197 EF                MOV     A,R7
0198 8EF0              MOV     B,R6
019A A4                MUL     AB
019B FF                MOV     R7,A
019C AEF0              MOV     R6,B
019E EF                MOV     A,R7
019F 24B4              ADD     A,#0B4H
01A1 FF                MOV     R7,A
01A2 EE                MOV     A,R6
01A3 34A0              ADDC    A,#0A0H
01A5 FE                MOV     R6,A
01A6 AA06              MOV     R2,AR6
01A8 A907              MOV     R1,AR7
01AA 7B01              MOV     R3,#01H
01AC 120000      E     LCALL   _cyread32_nodpx
01AF 900000      R     MOV     DPTR,#rxConfig
01B2 120000      E     LCALL   ?C?PLDXDATA
01B5 E9                MOV     A,R1
01B6 2409              ADD     A,#09H
01B8 F9                MOV     R1,A
01B9 EA                MOV     A,R2
01BA 3400              ADDC    A,#00H
01BC FA                MOV     R2,A
01BD 120000      E     LCALL   ?C?LLDPTR0
01C0 C3                CLR     C
01C1 120000      E     LCALL   ?C?ULCMP
01C4 6003              JZ      $ + 5H
01C6 020000      R     LJMP    ?C0097
                                           ; SOURCE LINE # 1346
                                           ; SOURCE LINE # 1348
01C9 900000      R     MOV     DPTR,#rxConfig
01CC 120000      E     LCALL   ?C?PLDXDATA
01CF 120000      E     LCALL   ?C?CLDPTR
01D2 FF                MOV     R7,A
01D3 7E20              MOV     R6,#020H
01D5 EF                MOV     A,R7
01D6 8EF0              MOV     B,R6
01D8 A4                MUL     AB
01D9 FF                MOV     R7,A
01DA AEF0              MOV     R6,B
01DC EF                MOV     A,R7
01DD 24B8              ADD     A,#0B8H
01DF FF                MOV     R7,A
01E0 EE                MOV     A,R6
01E1 34A0              ADDC    A,#0A0H
01E3 FE                MOV     R6,A
01E4 AA06              MOV     R2,AR6
01E6 A907              MOV     R1,AR7
01E8 7B01              MOV     R3,#01H
01EA 7FFF              MOV     R7,#0FFH
01EC 7EFF              MOV     R6,#0FFH
01EE 7DFF              MOV     R5,#0FFH
01F0 7CFF              MOV     R4,#0FFH
01F2 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1349
01F5 900000      R     MOV     DPTR,#rxConfig
01F8 120000      E     LCALL   ?C?PLDXDATA
01FB 120000      E     LCALL   ?C?CLDPTR
01FE FF                MOV     R7,A
01FF 7E20              MOV     R6,#020H
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 62  

0201 EF                MOV     A,R7
0202 8EF0              MOV     B,R6
0204 A4                MUL     AB
0205 FF                MOV     R7,A
0206 AEF0              MOV     R6,B
0208 EF                MOV     A,R7
0209 24B8              ADD     A,#0B8H
020B FF                MOV     R7,A
020C EE                MOV     A,R6
020D 34A0              ADDC    A,#0A0H
020F FE                MOV     R6,A
0210 AA06              MOV     R2,AR6
0212 A907              MOV     R1,AR7
0214 7B01              MOV     R3,#01H
0216 120000      E     LCALL   _cyread32_nodpx
0219 7BFF              MOV     R3,#0FFH
021B 7AFF              MOV     R2,#0FFH
021D 79FF              MOV     R1,#0FFH
021F 78FF              MOV     R0,#0FFH
0221 C3                CLR     C
0222 120000      E     LCALL   ?C?ULCMP
0225 7059              JNZ     ?C0097
                                           ; SOURCE LINE # 1350
                                           ; SOURCE LINE # 1352
0227 900000      R     MOV     DPTR,#rxConfig
022A 120000      E     LCALL   ?C?PLDXDATA
022D 120000      E     LCALL   ?C?CLDPTR
0230 FF                MOV     R7,A
0231 7E20              MOV     R6,#020H
0233 EF                MOV     A,R7
0234 8EF0              MOV     B,R6
0236 A4                MUL     AB
0237 FF                MOV     R7,A
0238 AEF0              MOV     R6,B
023A EF                MOV     A,R7
023B 24BC              ADD     A,#0BCH
023D FF                MOV     R7,A
023E EE                MOV     A,R6
023F 34A0              ADDC    A,#0A0H
0241 FE                MOV     R6,A
0242 AA06              MOV     R2,AR6
0244 A907              MOV     R1,AR7
0246 7B01              MOV     R3,#01H
0248 7F00              MOV     R7,#00H
024A 7E00              MOV     R6,#00H
024C 7D00              MOV     R5,#00H
024E 7C00              MOV     R4,#00H
0250 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1353
0253 900000      R     MOV     DPTR,#rxConfig
0256 120000      E     LCALL   ?C?PLDXDATA
0259 120000      E     LCALL   ?C?CLDPTR
025C FF                MOV     R7,A
025D 7E20              MOV     R6,#020H
025F EF                MOV     A,R7
0260 8EF0              MOV     B,R6
0262 A4                MUL     AB
0263 FF                MOV     R7,A
0264 AEF0              MOV     R6,B
0266 EF                MOV     A,R7
0267 24BC              ADD     A,#0BCH
0269 FF                MOV     R7,A
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 63  

026A EE                MOV     A,R6
026B 34A0              ADDC    A,#0A0H
026D FE                MOV     R6,A
026E AA06              MOV     R2,AR6
0270 A907              MOV     R1,AR7
0272 7B01              MOV     R3,#01H
0274 120000      E     LCALL   _cyread32_nodpx
0277 EF                MOV     A,R7
0278 4E                ORL     A,R6
0279 7005              JNZ     ?C0097
                                           ; SOURCE LINE # 1354
                                           ; SOURCE LINE # 1355
027B 900000      R     MOV     DPTR,#result
027E E4                CLR     A
027F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1356
                                           ; SOURCE LINE # 1357
                                           ; SOURCE LINE # 1358
                                           ; SOURCE LINE # 1359
                                           ; SOURCE LINE # 1360
0280         ?C0097:
                                           ; SOURCE LINE # 1362
0280 900000      R     MOV     DPTR,#result
0283 E0                MOVX    A,@DPTR
0284 FF                MOV     R7,A
                                           ; SOURCE LINE # 1363
0285         ?C0102:
0285 22                RET     
             ; FUNCTION _CAN_RxBufConfig (END)

             ; FUNCTION _CAN_TxBufConfig (BEGIN)
                                           ; SOURCE LINE # 1385
0000 900000      R     MOV     DPTR,#txConfig
0003 120000      E     LCALL   ?C?PSTXDATA
                                           ; SOURCE LINE # 1387
                                           ; SOURCE LINE # 1388
0006 900000      R     MOV     DPTR,#result
0009 7401              MOV     A,#01H
000B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1391
000C 900000      R     MOV     DPTR,#txConfig
000F 120000      E     LCALL   ?C?PLDXDATA
0012 120000      E     LCALL   ?C?CLDPTR
0015 FF                MOV     R7,A
0016 7E10              MOV     R6,#010H
0018 EF                MOV     A,R7
0019 8EF0              MOV     B,R6
001B A4                MUL     AB
001C FF                MOV     R7,A
001D AEF0              MOV     R6,B
001F EF                MOV     A,R7
0020 2420              ADD     A,#020H
0022 FF                MOV     R7,A
0023 EE                MOV     A,R6
0024 34A0              ADDC    A,#0A0H
0026 FE                MOV     R6,A
0027 AA06              MOV     R2,AR6
0029 A907              MOV     R1,AR7
002B 7B01              MOV     R3,#01H
002D C003              PUSH    AR3
002F C002              PUSH    AR2
0031 C001              PUSH    AR1
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 64  

0033 900000      R     MOV     DPTR,#txConfig
0036 120000      E     LCALL   ?C?PLDXDATA
0039 E9                MOV     A,R1
003A 2401              ADD     A,#01H
003C F9                MOV     R1,A
003D EA                MOV     A,R2
003E 3400              ADDC    A,#00H
0040 FA                MOV     R2,A
0041 120000      E     LCALL   ?C?LLDPTR
0044 EF                MOV     A,R7
0045 4408              ORL     A,#08H
0047 FF                MOV     R7,A
0048 EE                MOV     A,R6
0049 4400              ORL     A,#00H
004B FE                MOV     R6,A
004C ED                MOV     A,R5
004D 4480              ORL     A,#080H
004F FD                MOV     R5,A
0050 EC                MOV     A,R4
0051 4400              ORL     A,#00H
0053 FC                MOV     R4,A
0054 D001              POP     AR1
0056 D002              POP     AR2
0058 D003              POP     AR3
005A 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1393
005D 900000      R     MOV     DPTR,#txConfig
0060 120000      E     LCALL   ?C?PLDXDATA
0063 120000      E     LCALL   ?C?CLDPTR
0066 FF                MOV     R7,A
0067 7E10              MOV     R6,#010H
0069 EF                MOV     A,R7
006A 8EF0              MOV     B,R6
006C A4                MUL     AB
006D FF                MOV     R7,A
006E AEF0              MOV     R6,B
0070 EF                MOV     A,R7
0071 2420              ADD     A,#020H
0073 FF                MOV     R7,A
0074 EE                MOV     A,R6
0075 34A0              ADDC    A,#0A0H
0077 FE                MOV     R6,A
0078 AA06              MOV     R2,AR6
007A A907              MOV     R1,AR7
007C 7B01              MOV     R3,#01H
007E 120000      E     LCALL   _cyread32_nodpx
0081 EF                MOV     A,R7
0082 54F7              ANL     A,#0F7H
0084 FF                MOV     R7,A
0085 EE                MOV     A,R6
0086 5400              ANL     A,#00H
0088 FE                MOV     R6,A
0089 ED                MOV     A,R5
008A 547F              ANL     A,#07FH
008C FD                MOV     R5,A
008D EC                MOV     A,R4
008E 5400              ANL     A,#00H
0090 FC                MOV     R4,A
0091 C004              PUSH    AR4
0093 C005              PUSH    AR5
0095 C006              PUSH    AR6
0097 C007              PUSH    AR7
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 65  

0099 900000      R     MOV     DPTR,#txConfig
009C 120000      E     LCALL   ?C?PLDXDATA
009F E9                MOV     A,R1
00A0 2401              ADD     A,#01H
00A2 F9                MOV     R1,A
00A3 EA                MOV     A,R2
00A4 3400              ADDC    A,#00H
00A6 FA                MOV     R2,A
00A7 120000      E     LCALL   ?C?LLDPTR
00AA EF                MOV     A,R7
00AB 54F7              ANL     A,#0F7H
00AD FB                MOV     R3,A
00AE EE                MOV     A,R6
00AF 54FF              ANL     A,#0FFH
00B1 FA                MOV     R2,A
00B2 ED                MOV     A,R5
00B3 547F              ANL     A,#07FH
00B5 F9                MOV     R1,A
00B6 EC                MOV     A,R4
00B7 54FF              ANL     A,#0FFH
00B9 F8                MOV     R0,A
00BA D007              POP     AR7
00BC D006              POP     AR6
00BE D005              POP     AR5
00C0 D004              POP     AR4
00C2 C3                CLR     C
00C3 120000      E     LCALL   ?C?ULCMP
00C6 6003              JZ      $ + 5H
00C8 020000      R     LJMP    ?C0103
                                           ; SOURCE LINE # 1394
                                           ; SOURCE LINE # 1396
00CB 900000      R     MOV     DPTR,#txConfig
00CE 120000      E     LCALL   ?C?PLDXDATA
00D1 120000      E     LCALL   ?C?CLDPTR
00D4 FF                MOV     R7,A
00D5 7E10              MOV     R6,#010H
00D7 EF                MOV     A,R7
00D8 8EF0              MOV     B,R6
00DA A4                MUL     AB
00DB FF                MOV     R7,A
00DC AEF0              MOV     R6,B
00DE EF                MOV     A,R7
00DF 2424              ADD     A,#024H
00E1 FF                MOV     R7,A
00E2 EE                MOV     A,R6
00E3 34A0              ADDC    A,#0A0H
00E5 FE                MOV     R6,A
00E6 AA06              MOV     R2,AR6
00E8 A907              MOV     R1,AR7
00EA 7B01              MOV     R3,#01H
00EC C003              PUSH    AR3
00EE C002              PUSH    AR2
00F0 C001              PUSH    AR1
00F2 900000      R     MOV     DPTR,#txConfig
00F5 120000      E     LCALL   ?C?PLDXDATA
00F8 E9                MOV     A,R1
00F9 2405              ADD     A,#05H
00FB F9                MOV     R1,A
00FC EA                MOV     A,R2
00FD 3400              ADDC    A,#00H
00FF FA                MOV     R2,A
0100 120000      E     LCALL   ?C?LLDPTR
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 66  

0103 D001              POP     AR1
0105 D002              POP     AR2
0107 D003              POP     AR3
0109 120000      E     LCALL   _cywrite32_nodpx
                                           ; SOURCE LINE # 1397
010C 900000      R     MOV     DPTR,#txConfig
010F 120000      E     LCALL   ?C?PLDXDATA
0112 120000      E     LCALL   ?C?CLDPTR
0115 FF                MOV     R7,A
0116 7E10              MOV     R6,#010H
0118 EF                MOV     A,R7
0119 8EF0              MOV     B,R6
011B A4                MUL     AB
011C FF                MOV     R7,A
011D AEF0              MOV     R6,B
011F EF                MOV     A,R7
0120 2424              ADD     A,#024H
0122 FF                MOV     R7,A
0123 EE                MOV     A,R6
0124 34A0              ADDC    A,#0A0H
0126 FE                MOV     R6,A
0127 AA06              MOV     R2,AR6
0129 A907              MOV     R1,AR7
012B 7B01              MOV     R3,#01H
012D 120000      E     LCALL   _cyread32_nodpx
0130 900000      R     MOV     DPTR,#txConfig
0133 120000      E     LCALL   ?C?PLDXDATA
0136 E9                MOV     A,R1
0137 2405              ADD     A,#05H
0139 F9                MOV     R1,A
013A EA                MOV     A,R2
013B 3400              ADDC    A,#00H
013D FA                MOV     R2,A
013E 120000      E     LCALL   ?C?LLDPTR0
0141 C3                CLR     C
0142 120000      E     LCALL   ?C?ULCMP
0145 7005              JNZ     ?C0103
                                           ; SOURCE LINE # 1398
                                           ; SOURCE LINE # 1399
0147 900000      R     MOV     DPTR,#result
014A E4                CLR     A
014B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1400
                                           ; SOURCE LINE # 1401
014C         ?C0103:
                                           ; SOURCE LINE # 1403
014C 900000      R     MOV     DPTR,#result
014F E0                MOVX    A,@DPTR
0150 FF                MOV     R7,A
                                           ; SOURCE LINE # 1404
0151         ?C0105:
0151 22                RET     
             ; FUNCTION _CAN_TxBufConfig (END)



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3253    ----
   CONSTANT SIZE    =    280    ----
   XDATA SIZE       =      1      64
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.51   CAN                                                                   11/19/2018 18:58:11 PAGE 67  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
